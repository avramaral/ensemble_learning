if (file.exists(naive_ensemble_file)) {
naive_ensemble <- readRDS(file = naive_ensemble_file)
} else {
naive_ensemble <- compute_naive_ensemble(data = data, loc = state, age_gr = age)
saveRDS(object = naive_ensemble, file = naive_ensemble_file)
}
data <- rbind(data, naive_ensemble)
models <- c(models, "Mean", "Median")
colors <- c(colors, "#009E73", "#60D1B3")
##################################################
# FORMAT DATA
# Create the objects `y`, `y_current`, `values`, and `current`
##################################################
retrieved_data_file <- paste("DATA/TRAINING/retrieved_data_training_size_", training_size, "_state_", state, "_age_", age, ".RDS", sep = "")
if (file.exists(retrieved_data_file)) {
retrieved_data <- readRDS(file = retrieved_data_file)
} else {
retrieved_data <- retrieve_data(data = data, truth_data = truth_data, naive_ensemble = naive_ensemble, models = models, horizon = horizon, start_date = r[1], end_date = r[2], skip_first_days = 1, training_size = training_size)
saveRDS(object = retrieved_data, file = retrieved_data_file)
}
source("header.R")
source("utils.R")
source("aux.R")
ens_method <- "wis" # c("wis", "pinball")
skip_recent_days <- TRUE
uncertain_size <- 40
exploratory_wis <- FALSE # Plotting score for all individual and naive ensemble models
ignore_naive_ensemble_data <- TRUE # Remove naive ensembles from the data objects, so the trained models do not take them as inputs
quant <- TRUE # Weights depend (or not) on the quantiles
horiz <- TRUE # Weights depend (or not) on the horizons (not fully implemented, and partially implemented for `pinball`)
##################################################
# FILTER DATA
# `state_idx` and `age_idx` must be selected
##################################################
training_size <- 90
state_idx <- 17
age_idx <- 7
data <- read_csv(file = "DATA/data.csv.gz")
truth_data <- read_csv(file = "DATA/truth_40d.csv.gz")
state <- unique(data$location)
state <- c(state, "DE")
state <- state[2:length(state)][state_idx]
age <- unique(data$age_group)
age <- c(age, "00+")
age <- age[2:length(age)][age_idx]
models <- c("Epiforecasts", "ILM", "KIT", "LMU", "RIVM", "RKI", "SU", "SZ")
colors <- c("#B30000", "#E69F00", "#56B4E9", "#F0E442", "#80471C", "#3C4AAD", "#CC79A7", "#000000")
ens_models <- models
ens_colors <- colors
filtered_data <- filter_data(data = data, truth_data = truth_data, models = models, loc = state, age_gr = age, extra_delay = 7, truth_past = training_size)
data <- filtered_data$data
truth_data <- filtered_data$truth_data
r <- range(data$forecast_date)
horizon <- -28:0
probs <- c(0.025, 0.100, 0.250, 0.500, 0.750, 0.900, 0.975)
##################################################
# UNTRAINED ENSEMBLE
# Compute the naive ensemble using `mean` and `median`
##################################################
naive_ensemble_file <- paste("DATA/UNTRAINED_ENSEMBLE/naive_ensemble_state_", state, "_age_", age, ".RDS", sep = "")
if (file.exists(naive_ensemble_file)) {
naive_ensemble <- readRDS(file = naive_ensemble_file)
} else {
naive_ensemble <- compute_naive_ensemble(data = data, loc = state, age_gr = age)
saveRDS(object = naive_ensemble, file = naive_ensemble_file)
}
data <- rbind(data, naive_ensemble)
models <- c(models, "Mean", "Median")
colors <- c(colors, "#009E73", "#60D1B3")
##################################################
# FORMAT DATA
# Create the objects `y`, `y_current`, `values`, and `current`
##################################################
retrieved_data_file <- paste("DATA/TRAINING/retrieved_data_training_size_", training_size, "_state_", state, "_age_", age, ".RDS", sep = "")
if (file.exists(retrieved_data_file)) {
retrieved_data <- readRDS(file = retrieved_data_file)
} else {
retrieved_data <- retrieve_data(data = data, truth_data = truth_data, naive_ensemble = naive_ensemble, models = models, horizon = horizon, start_date = r[1], end_date = r[2], skip_first_days = 1, training_size = training_size)
saveRDS(object = retrieved_data, file = retrieved_data_file)
}
y         <- retrieved_data$y
y_current <- retrieved_data$y_current
values    <- retrieved_data$values
current   <- retrieved_data$current
if (ignore_naive_ensemble_data) { # Remove `Mean` and `Median` from the data objects
new_tmp_data <- process_data_ignore_naive(current = current, values = values, n_models = length(ens_models))
current <- new_tmp_data$current
values <- new_tmp_data$values
}
if (skip_recent_days) {
skip_days_data_file <- paste("DATA/TRAINING/skip_days_data_size_", training_size, "_state_", state, "_age_", age, ".RDS", sep = "")
if (file.exists(skip_days_data_file)) {
skip_days_data <- readRDS(file = skip_days_data_file)
} else {
new_tmp_data <- process_data_skip_days(y = y, values = values, uncertain_size = uncertain_size)
y      <- new_tmp_data$y
values <- new_tmp_data$values
saveRDS(object = list(y = y, y_current = y_current, values = values, current = current), file = skip_days_data_file)
}
}
##################################################
# COMPUTE SCORE
# Compute WIS for all models, given truth final data (exploratory analysis)
##################################################
if (exploratory_wis) {
# Make all models comparable: `skip_first_days = 40 + 1`
wis_truth <- compute_wis_truth(data = data, truth_data = truth_data, models = models, horizon = horizon, start_date = r[1], end_date = r[2], skip_first_days = 41)
df_wis <- wis_truth$df_wis
wis_summ <- wis_truth$wis_summ
# Bar plot
plot_wis_bar(df_wis = df_wis, wis_summ = wis_summ, models = models, colors = colors, ylim_manual = 200)
# Line plot over the horizons
df_wis_horizon_truth <- compute_wis_horizon_truth(models = models, horizon = horizon, wis_summ = wis_summ)
plot_wis_line_horizon(df_wis_horizon = df_wis_horizon_truth, models = models, colors = colors)
}
##################################################
# COMPUTE SCORE (INCOMPLETE DATA)
# Compute WIS for all models, based on the yet-to-be-corrected nowcasts (used to compute weights)
##################################################
if (ens_method == "wis") {
wis_file <- paste("DATA/TRAINING/WIS/wis_weights_size_", training_size, "_state_", state, "_age_", age, "_quant_", as.character(quant), ".RDS", sep = "")
if (file.exists(wis_file)) {
wis_training_list <- readRDS(file = wis_file)
} else {
wis_training_list <- compute_wis_training(data = values, truth_data = y, start_date = r[1], end_date = r[2], horizon = horizon, models = models, training_size = training_size, skip_first_days = skip_first_days, quant = quant)
saveRDS(object = wis_training_list, file = wis_file)
}
wis <- wis_training_list$wis
wis_avg <- wis_training_list$wis_avg
weights <- lapply(X = wis, FUN = compute_weights)
# Line plot over the horizons for training
df_wis_horizon_training <- compute_wis_horizon_training(wis_avg = wis_avg, models = models, quant = quant)
plot_wis_line_horizon(df_wis_horizon = df_wis_horizon_training, models = models, colors = colors, quant = quant, legend = TRUE)
}
exploratory_wis
if (ens_method == "wis") {
wis_file <- paste("DATA/TRAINING/WIS/wis_weights_size_", training_size, "_state_", state, "_age_", age, "_quant_", as.character(quant), ".RDS", sep = "")
if (file.exists(wis_file)) {
wis_training_list <- readRDS(file = wis_file)
} else {
wis_training_list <- compute_wis_training(data = values, truth_data = y, start_date = r[1], end_date = r[2], horizon = horizon, models = ens_models, training_size = training_size, skip_first_days = skip_first_days, quant = quant)
saveRDS(object = wis_training_list, file = wis_file)
}
wis <- wis_training_list$wis
wis_avg <- wis_training_list$wis_avg
weights <- lapply(X = wis, FUN = compute_weights)
# Line plot over the horizons for training
df_wis_horizon_training <- compute_wis_horizon_training(wis_avg = wis_avg, models = ens_models, quant = quant)
plot_wis_line_horizon(df_wis_horizon = df_wis_horizon_training, models = ens_models, colors = colors, quant = quant, legend = TRUE)
}
new_data <- create_new_tibble()
skip_first_days <- ifelse(skip_recent_days, uncertain_size + 1, 1)
days <- seq(r[1] + skip_first_days, r[2], by = "1 day")
ensemble <- list()
count <- 1
if (ens_method == "pinball") {
cl <- makeCluster(16)
registerDoParallel(cl = cl)
clusterExport(cl, c(""), envir = environment()) # Include exported functions
}
for (k in 1:length(days)) {
dt <- days[k]
ensemble[[as.character(dt)]] <- list()
print(paste(dt, " (", sprintf("%03d", count), "/", sprintf("%03d", length(days)), ")", sep = ""))
b <- txtProgressBar(min = 1, max = length(horizon), initial = 1)
for (i in 1:length(horizon)) {
h <- horizon[i]
current_ens <- current[[as.character(dt)]][[as.character(h)]][[1]]
values_ens  <- values[[as.character(dt)]][[as.character(h)]]
# Analyze `NaN` values
# TBD
if (ens_method == "wis") {
tmp_resul <- compute_ensemble(ens_method = ens_method, current = current_ens, weights = weights[[as.character(h)]], k = k)
} else if (ens_method == "pinball") {
tmp_resul <- compute_ensemble(ens_method = ens_method,
y = y[[as.character(dt)]][[as.character(h)]],
y_current = y_current[[as.character(dt)]][[as.character(h)]],
values = values_ens,
current = current_ens,
ens_models = ens_models,
lower = -10,
upper = 10,
quant = quant,
horiz = horiz,
probs = probs,
short_grid_search = TRUE,
by = 0.01)
} else {
stop("Choose a valid ensemble method.")
}
ensemble[[as.character(dt)]][[as.character(h)]] <- tmp_result
# Input the new data to the `new_data` tibble
new_data <- input_new_data(new_data = new_data, ensemble = ensemble, ens_method = ens_method, h = h, state = state, age = age, day = dt, probs = probs)
setTxtProgressBar(b, i)
}
close(b)
count <- count + 1
}
h <- horizon[i]
current_ens <- current[[as.character(dt)]][[as.character(h)]][[1]]
values_ens  <- values[[as.character(dt)]][[as.character(h)]]
if (ens_method == "wis") {
tmp_resul <- compute_ensemble(ens_method = ens_method, current = current_ens, weights = weights[[as.character(h)]], k = k)
} else if (ens_method == "pinball") {
tmp_resul <- compute_ensemble(ens_method = ens_method,
y = y[[as.character(dt)]][[as.character(h)]],
y_current = y_current[[as.character(dt)]][[as.character(h)]],
values = values_ens,
current = current_ens,
ens_models = ens_models,
lower = -10,
upper = 10,
quant = quant,
horiz = horiz,
probs = probs,
short_grid_search = TRUE,
by = 0.01)
} else {
stop("Choose a valid ensemble method.")
}
ensemble[[as.character(dt)]][[as.character(h)]] <- tmp_result
for (k in 1:length(days)) {
dt <- days[k]
ensemble[[as.character(dt)]] <- list()
print(paste(dt, " (", sprintf("%03d", count), "/", sprintf("%03d", length(days)), ")", sep = ""))
b <- txtProgressBar(min = 1, max = length(horizon), initial = 1)
for (i in 1:length(horizon)) {
h <- horizon[i]
current_ens <- current[[as.character(dt)]][[as.character(h)]][[1]]
values_ens  <- values[[as.character(dt)]][[as.character(h)]]
# Analyze `NaN` values
# TBD
if (ens_method == "wis") {
tmp_result <- compute_ensemble(ens_method = ens_method, current = current_ens, weights = weights[[as.character(h)]], k = k)
} else if (ens_method == "pinball") {
tmp_result <- compute_ensemble(ens_method = ens_method,
y = y[[as.character(dt)]][[as.character(h)]],
y_current = y_current[[as.character(dt)]][[as.character(h)]],
values = values_ens,
current = current_ens,
ens_models = ens_models,
lower = -10,
upper = 10,
quant = quant,
horiz = horiz,
probs = probs,
short_grid_search = TRUE,
by = 0.01)
} else {
stop("Choose a valid ensemble method.")
}
ensemble[[as.character(dt)]][[as.character(h)]] <- tmp_result
# Input the new data to the `new_data` tibble
new_data <- input_new_data(new_data = new_data, ensemble = ensemble, ens_method = ens_method, h = h, state = state, age = age, day = dt, probs = probs)
setTxtProgressBar(b, i)
}
close(b)
count <- count + 1
}
if (ens_method == "pinball") { stopCluster(cl) }
saveRDS(object = list(ensemble = ensemble, new_data = new_data), file = paste("RESULTS/FITTED_OBJECTS/method_", ens_method, "_size_", training_size, "_skip_", as.character(skip_recent_days), "_state_", state, "_age_", age, "_quant_", as.character(quant), ".RDS", sep = ""))
weights$`0`
weights$`0` %>% dim()
source("header.R")
source("utils.R")
source("aux.R")
ens_method <- "pinball" # c("wis", "pinball")
skip_recent_days <- TRUE
uncertain_size <- 40
exploratory_wis <- FALSE # Plotting score for all individual and naive ensemble models
ignore_naive_ensemble_data <- TRUE # Remove naive ensembles from the data objects, so the trained models do not take them as inputs
quant <- TRUE # Weights depend (or not) on the quantiles
horiz <- TRUE # Weights depend (or not) on the horizons (not fully implemented, and partially implemented for `pinball`)
##################################################
# FILTER DATA
# `state_idx` and `age_idx` must be selected
##################################################
training_size <- 90
state_idx <- 17
age_idx <- 7
data <- read_csv(file = "DATA/data.csv.gz")
truth_data <- read_csv(file = "DATA/truth_40d.csv.gz")
state <- unique(data$location)
state <- c(state, "DE")
state <- state[2:length(state)][state_idx]
age <- unique(data$age_group)
age <- c(age, "00+")
age <- age[2:length(age)][age_idx]
models <- c("Epiforecasts", "ILM", "KIT", "LMU", "RIVM", "RKI", "SU", "SZ")
colors <- c("#B30000", "#E69F00", "#56B4E9", "#F0E442", "#80471C", "#3C4AAD", "#CC79A7", "#000000")
ens_models <- models
ens_colors <- colors
filtered_data <- filter_data(data = data, truth_data = truth_data, models = models, loc = state, age_gr = age, extra_delay = 7, truth_past = training_size)
data <- filtered_data$data
truth_data <- filtered_data$truth_data
r <- range(data$forecast_date)
horizon <- -28:0
probs <- c(0.025, 0.100, 0.250, 0.500, 0.750, 0.900, 0.975)
##################################################
# UNTRAINED ENSEMBLE
# Compute the naive ensemble using `mean` and `median`
##################################################
naive_ensemble_file <- paste("DATA/UNTRAINED_ENSEMBLE/naive_ensemble_state_", state, "_age_", age, ".RDS", sep = "")
if (file.exists(naive_ensemble_file)) {
naive_ensemble <- readRDS(file = naive_ensemble_file)
} else {
naive_ensemble <- compute_naive_ensemble(data = data, loc = state, age_gr = age)
saveRDS(object = naive_ensemble, file = naive_ensemble_file)
}
data <- rbind(data, naive_ensemble)
models <- c(models, "Mean", "Median")
colors <- c(colors, "#009E73", "#60D1B3")
##################################################
# FORMAT DATA
# Create the objects `y`, `y_current`, `values`, and `current`
##################################################
retrieved_data_file <- paste("DATA/TRAINING/retrieved_data_training_size_", training_size, "_state_", state, "_age_", age, ".RDS", sep = "")
if (file.exists(retrieved_data_file)) {
retrieved_data <- readRDS(file = retrieved_data_file)
} else {
retrieved_data <- retrieve_data(data = data, truth_data = truth_data, naive_ensemble = naive_ensemble, models = models, horizon = horizon, start_date = r[1], end_date = r[2], skip_first_days = 1, training_size = training_size)
saveRDS(object = retrieved_data, file = retrieved_data_file)
}
y         <- retrieved_data$y
y_current <- retrieved_data$y_current
values    <- retrieved_data$values
current   <- retrieved_data$current
if (ignore_naive_ensemble_data) { # Remove `Mean` and `Median` from the data objects
new_tmp_data <- process_data_ignore_naive(current = current, values = values, n_models = length(ens_models))
current <- new_tmp_data$current
values <- new_tmp_data$values
}
if (skip_recent_days) {
skip_days_data_file <- paste("DATA/TRAINING/skip_days_data_size_", training_size, "_state_", state, "_age_", age, ".RDS", sep = "")
if (file.exists(skip_days_data_file)) {
skip_days_data <- readRDS(file = skip_days_data_file)
} else {
new_tmp_data <- process_data_skip_days(y = y, values = values, uncertain_size = uncertain_size)
y      <- new_tmp_data$y
values <- new_tmp_data$values
saveRDS(object = list(y = y, y_current = y_current, values = values, current = current), file = skip_days_data_file)
}
}
##################################################
# COMPUTE SCORE
# Compute WIS for all models, given truth final data (exploratory analysis)
##################################################
if (exploratory_wis) {
# Make all models comparable: `skip_first_days = 40 + 1`
wis_truth <- compute_wis_truth(data = data, truth_data = truth_data, models = models, horizon = horizon, start_date = r[1], end_date = r[2], skip_first_days = 41)
df_wis <- wis_truth$df_wis
wis_summ <- wis_truth$wis_summ
# Bar plot
plot_wis_bar(df_wis = df_wis, wis_summ = wis_summ, models = models, colors = colors, ylim_manual = 200)
# Line plot over the horizons
df_wis_horizon_truth <- compute_wis_horizon_truth(models = models, horizon = horizon, wis_summ = wis_summ)
plot_wis_line_horizon(df_wis_horizon = df_wis_horizon_truth, models = models, colors = colors)
}
##################################################
# COMPUTE SCORE (INCOMPLETE DATA)
# Compute WIS for all models, based on the yet-to-be-corrected nowcasts (used to compute weights)
##################################################
if (ens_method == "wis") {
wis_file <- paste("DATA/TRAINING/WIS/wis_weights_size_", training_size, "_state_", state, "_age_", age, "_quant_", as.character(quant), ".RDS", sep = "")
if (file.exists(wis_file)) {
wis_training_list <- readRDS(file = wis_file)
} else {
wis_training_list <- compute_wis_training(data = values, truth_data = y, start_date = r[1], end_date = r[2], horizon = horizon, models = ens_models, training_size = training_size, skip_first_days = skip_first_days, quant = quant)
saveRDS(object = wis_training_list, file = wis_file)
}
wis <- wis_training_list$wis
wis_avg <- wis_training_list$wis_avg
weights <- lapply(X = wis, FUN = compute_weights)
# Line plot over the horizons for training
df_wis_horizon_training <- compute_wis_horizon_training(wis_avg = wis_avg, models = ens_models, quant = quant)
plot_wis_line_horizon(df_wis_horizon = df_wis_horizon_training, models = ens_models, colors = colors, quant = quant, legend = TRUE)
}
##################################################
# FIT THE MODEL
# Estimate scale and weight parameters and compute new nowcasts (based on different methods)
##################################################
new_data <- create_new_tibble()
skip_first_days <- ifelse(skip_recent_days, uncertain_size + 1, 1)
days <- seq(r[1] + skip_first_days, r[2], by = "1 day")
ensemble <- list()
count <- 1
if (ens_method == "pinball") {
cl <- makeCluster(16)
registerDoParallel(cl = cl)
clusterExport(cl, c("cost_function", "par_weights_scale", "cost_function_weights_ind", "compute_wis", "mpfr"), envir = environment()) # Include exported functions
}
if (ens_method == "pinball") {
cl <- makeCluster(16)
registerDoParallel(cl = cl)
clusterExport(cl, c("cost_function", "par_weights_scale", "compute_wis", "mpfr"), envir = environment()) # Include exported functions
}
for (k in 1:length(days)) {
dt <- days[k]
ensemble[[as.character(dt)]] <- list()
print(paste(dt, " (", sprintf("%03d", count), "/", sprintf("%03d", length(days)), ")", sep = ""))
b <- txtProgressBar(min = 1, max = length(horizon), initial = 1)
for (i in 1:length(horizon)) {
h <- horizon[i]
current_ens <- current[[as.character(dt)]][[as.character(h)]][[1]]
values_ens  <- values[[as.character(dt)]][[as.character(h)]]
# Analyze `NaN` values
# TBD
if (ens_method == "wis") {
tmp_result <- compute_ensemble(ens_method = ens_method, current = current_ens, weights = weights[[as.character(h)]], k = k)
} else if (ens_method == "pinball") {
tmp_result <- compute_ensemble(ens_method = ens_method,
y = y[[as.character(dt)]][[as.character(h)]],
y_current = y_current[[as.character(dt)]][[as.character(h)]],
values = values_ens,
current = current_ens,
ens_models = ens_models,
lower = -10,
upper = 10,
quant = quant,
horiz = horiz,
probs = probs,
short_grid_search = TRUE,
by = 0.01)
} else {
stop("Choose a valid ensemble method.")
}
ensemble[[as.character(dt)]][[as.character(h)]] <- tmp_result
# Input the new data to the `new_data` tibble
new_data <- input_new_data(new_data = new_data, ensemble = ensemble, ens_method = ens_method, h = h, state = state, age = age, day = dt, probs = probs)
setTxtProgressBar(b, i)
}
close(b)
count <- count + 1
}
warnings()
y = y[[as.character(dt)]][[as.character(h)]]
y_current = y_current[[as.character(dt)]][[as.character(h)]]
values = values_ens
current = current_ens
lower = -10
upper = 10
short_grid_search = TRUE
by = 0.01
if (!horiz) { current <- list(current) }
if (!horiz & !quant) { stop("This combination of `quant` and `horiz` is not implemented.") }
if (horiz) { # Weights depend on the horizons
N <- length(values)
M <- nrow(values[[1]])
if (is.null(M)) {
M <- 1
}
} else { # Weights do not depend on the horizons
H <- length(values)
N <- length(values[[1]])
M <- nrow(values[[1]][[1]])
}
if (!quant) { # Weights do not depend on the quantiles
wis <- matrix(data = 0, nrow = N, ncol = M)
} else { # Weights depend on the quantiles
if (horiz) {
wis <- array(data = 0, dim = c(N, M, length(probs)))
} else {
wis <- array(data = 0, dim = c((N * H), M, length(probs)))
}
}
# Compute the score (WIS)
if (horiz) {
for (n in 1:N) {
if (!quant) { # Missing implementation for more than one model
wis[n, ] <- apply(X = values[[n]], MARGIN = 1, FUN = compute_wis, probs = probs, y = y[n], average = (!quant))
} else {
if (M == 1) {
wis[n, , ] <- compute_wis(probs = probs, quant = values[[n]], y = y[n], average = (!quant))
} else {
wis[n, , ] <- apply(X = values[[n]], MARGIN = 1, FUN = compute_wis, probs = probs, y = y[n], average = (!quant)) |> t()
}
}
}
} else {
horizon <- as.numeric(names(y))
count <- 1
for (n in 1:N) {
for (h in 1:H) {
wis[count, , ] <- apply(X = values[[as.character(horizon[h])]][[n]], MARGIN = 1, FUN = compute_wis, probs = probs, y = y[[as.character(horizon[h])]][n], average = (!quant)) |> t()
count <- count + 1
}
}
}
# Optimization routine
if (sum(wis, na.rm = TRUE) == 0) {
theta <- 0
} else {
if (!quant) {
# To be implemented
} else {
theta <- rep(x = 0, times = length(probs))
phi <- rep(x = 0, times = length(probs))
for (q in 1:length(probs)) {
tmp_wis <- wis[, , q]
if (is.null(dim(tmp_wis))) {
tmp_wis <- t(as.matrix(tmp_wis))
}
est_pars <- grid_optim(probs = probs, values = values, y = y, q = q, quant = quant, M = M, wis = tmp_wis, by = by, theta_lim = c(lower, upper), horiz = horiz, short_grid_search = short_grid_search)
if (M == 1) {
phi[q] <- est_pars[1]
} else {
theta[q] <- est_pars[1]
phi[q]   <- est_pars[2]
}
}
}
}
