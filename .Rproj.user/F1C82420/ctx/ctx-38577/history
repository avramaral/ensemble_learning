values[[values_idx_1[i]]][[as.character(values_idx_2[j])]][(1:uncertain_size)] <- NULL
y[[values_idx_1[i]]][[as.character(values_idx_2[j])]] <- y[[values_idx_1[i]]][[as.character(values_idx_2[j])]][-(1:uncertain_size)]
}
setTxtProgressBar(b, i)
}
close(b)
list(y = y, values = values)
}
##################################################
##################################################
##################################################
process_data_ignore_naive <- function (current, values, n_models = 8, ...) {
N <- length(values)
H <- length(values[[1]])
b <- txtProgressBar(min = 1, max = N, initial = 1)
for (n in 1:N) {
for (h in 1:H) {
tmp_count <- length(values[[n]][[h]])
for (count in 1:tmp_count) {
values[[n]][[h]][[count]] <- values[[n]][[h]][[count]][1:n_models, ]
}
current[[n]][[h]][[1]] <- current[[n]][[h]][[1]][1:n_models, ]
}
setTxtProgressBar(b, n)
}
close(b)
list(current = current, values = values)
}
##################################################
##################################################
##################################################
compute_wis_training_horizon <- function (data, truth_data, start_date, end_date, horizon, models, training_size, skip_first_days = 1, quant = TRUE, probs = c(0.025, 0.100, 0.250, 0.500, 0.750, 0.900, 0.975), ...) {
days <- seq(start_date + skip_first_days, end_date, by = "1 day")
if (!quant) {
wis <- matrix(data = 0, nrow = length(days), ncol = length(models))
} else {
wis <- array(data = 0, dim = c(length(days), length(models), length(probs)))
}
b <- txtProgressBar(min = 0, max = length(days), initial = 0)
for (k in 1:length(days)) {
dt <- days[k]
number_days <- as.numeric((dt - start_date))
number_days <- min(number_days, training_size)
number_days <- number_days - (skip_first_days - 1)
if (!quant) {
wis_tmp <- matrix(data = 0, nrow = number_days, ncol = length(models))
} else {
wis_tmp <- array(data = 0, dim = c(number_days, length(models), length(probs)))
}
for (n in 1:number_days) {
tmp_data <- data[[as.character(dt)]][[as.character(horizon)]][[n]]
tmp_y <- truth_data[[as.character(dt)]][[as.character(horizon)]][n]
for (m in 1:length(models)) {
if (!quant) {
wis_tmp[n, m  ] <- compute_wis(probs = probs, quant = tmp_data[m, ], y = tmp_y, average = (!quant))
} else {
wis_tmp[n, m, ] <- compute_wis(probs = probs, quant = tmp_data[m, ], y = tmp_y, average = (!quant))
}
}
}
if (!quant) {
wis[k,   ] <- apply(X = wis_tmp, MARGIN = 2      , FUN = mean)
} else {
wis[k, , ] <- apply(X = wis_tmp, MARGIN = c(2, 3), FUN = mean)
}
setTxtProgressBar(b, k)
}
close(b)
wis
}
##################################################
##################################################
##################################################
compute_wis_training <- function (data, truth_data, start_date, end_date, horizon, models, training_size, skip_first_days = 1, quant = TRUE, probs = c(0.025, 0.100, 0.250, 0.500, 0.750, 0.900, 0.975), ...) {
wis <- list()
wis_avg <- list()
skip_first_days <- 1 + uncertain_size
for (h in horizon) {
print(paste("Horizon: ", h, sep = ""))
wis[[as.character(h)]] <- compute_wis_training_horizon(data = data, truth_data = truth_data, start_date = start_date, end_date = end_date, horizon = h, models = models, training_size = training_size, skip_first_days = skip_first_days, quant = quant)
if (!quant) {
wis_avg[[as.character(h)]] <- wis[[as.character(h)]] |> colMeans(na.rm = TRUE)
} else {
wis_avg[[as.character(h)]] <- apply(X = wis[[as.character(h)]], MARGIN = c(2, 3), FUN = mean, na.rm = TRUE)
}
}
list(wis = wis, wis_avg = wis_avg)
}
##################################################
##################################################
##################################################
compute_weights <- function (wis = NULL, ...) {
wis <- wis + 1e-6
weights <- 1 / wis
if (is.null(dim(weights))) { # Weights do not depend on time
weights <- weights / sum(weights, na.rm = TRUE)
} else { # Weights depend on time
if (length(dim(weights)) == 3) { # Weights depend on the quantiles
for (d in 1:(dim(weights)[1])) {
for (i in 1:(dim(weights)[3])) {
weights[d, , i] <- weights[d, , i] / sum(weights[d, , i], na.rm = TRUE)
}
}
} else { # Weights do not depend on the quantiles
for (i in 1:ncol(weights)) {
weights[, i] <- weights[, i] / sum(weights[, i], na.rm = TRUE)
}
}
}
weights
}
##################################################
##################################################
##################################################
compute_wis_horizon_training <- function (wis_avg, models, quant = TRUE, probs = c(0.025, 0.100, 0.250, 0.500, 0.750, 0.900, 0.975), ...) {
horizon <- as.numeric(names(wis_avg))
if (!quant) {
df_wis_horizon <- data.frame(model = rep(models, length(horizon)), horizon = rep(horizon, each = length(models)), wis = 0)
} else {
df_wis_horizon <- data.frame(model = rep(models, (length(horizon) * length(probs))), horizon = rep(rep(horizon, each = length(models)), length(probs)), probs = rep(probs, each = (length(models) * length(horizon))), wis = 0)
df_wis_horizon$probs <- factor(x = df_wis_horizon$probs, levels = probs)
}
df_wis_horizon$model <- factor(x = df_wis_horizon$model, levels = models)
for (h in horizon) {
df_wis_horizon[df_wis_horizon$horizon == h, "wis"] <- c(wis_avg[[as.character(h)]])
}
df_wis_horizon
}
##################################################
##################################################
##################################################
create_new_tibble <- function (...) {
as_tibble(data.frame(location         = character(),
age_group        = character(),
forecast_date    = as.Date(character()),
target_end_date  = as.Date(character()),
target           = character(),
type             = character(),
quantile         = double(),
value            = double(),
pathogen         = character(),
model            = character(),
retrospective    = logical(),
stringsAsFactors = FALSE))
}
##################################################
##################################################
##################################################
compute_ensemble <- function (ens_method, y, y_current, values, current, ens_models = NULL, weights = NULL, k = NULL, lower = -10, upper = 10, quant = TRUE, horiz = TRUE, probs = c(0.025, 0.100, 0.250, 0.500, 0.750, 0.900, 0.975), short_grid_search = TRUE, by = 0.01, ...) {
m <- ens_method[1]
if (m == "wis") {
res <- ensemble_wis(current = current, weights = weights, k = k)
} else if (m == "pinball") {
if (!horiz) { current <- list(current) }
res <- ensemble_pinball(y = y, y_current = y_currnt, values = values, current = current, ens_models = ens_models, lower = lower, upper = upper, quant = quant, horiz = horiz, probs = probs, short_grid_search = short_grid_search, by = by)
} else {
stop("Choose a valid ensemble method.")
}
res
}
##################################################
##################################################
##################################################
ensemble_wis <- function (current, weights, k = NULL, ...) {
if (length(dim(weights)) == 3) { # Weights depend on the quantiles
res <- rep(0, length(probs))
for (q in 1:length(probs)) {
res[q] <- weights[k, , q] %*% current[, q]
}
weights <- weights[k, , ]
} else { # Weights do not depend on the quantiles
if (is.null(nrow(weights))) {
res <- weights %*% current
} else {
res <- rep(0, length(probs))
for (q in 1:length(probs)) {
res[q] <- weights[, q] %*% current[, q]
}
}
}
list(nowcast = res, weights = weights)
}
##################################################
##################################################
##################################################
input_new_data <- function (new_data, ensemble, ens_method, h, state, age, day, probs = c(0.025, 0.100, 0.250, 0.500, 0.750, 0.900, 0.975), ..) {
name_method <- ifelse(ens_method == "wis", "DISW", "ISW")
for (q in 1:length(probs)) {
value <- ensemble[[as.character(dt)]][[as.character(h)]]$nowcast
if (class(value)[1] == "numeric") {
value <- value[q]
} else  {
value <- value[1, q]
}
new_data <- new_data |> add_row(location = state, age_group = age, forecast_date = dt, target_end_date = (dt + h), target = paste(h, " day ahead inc hosp", sep = ""), type = "quantile", quantile =  probs[q], value = value, pathogen = "COVID-19", model = name_method, retrospective = FALSE)
}
new_data
}
##################################################
##################################################
##################################################
ensemble_pinball <- function (y, y_current, values, current, ens_models = NULL, lower = -10, upper = 10, quant = TRUE, horiz = TRUE, probs = c(0.025, 0.100, 0.250, 0.500, 0.750, 0.900, 0.975), short_grid_search = TRUE, by = 0.01, ...) {
if (!horiz & !quant) { stop("This combination of `quant` and `horiz` is not implemented.") }
# H: number of horizons
# N: number of day points
# M: number of models
if (horiz) { # Weights depend on the horizons
N <- length(values)
M <- nrow(values[[1]])
if (is.null(M)) {
M <- 1
}
} else { # Weights do not depend on the horizons
H <- length(values)
N <- length(values[[1]])
M <- nrow(values[[1]][[1]])
}
if (!quant) { # Weights do not depend on the quantiles
wis <- matrix(data = 0, nrow = N, ncol = M)
} else { # Weights depend on the quantiles
if (horiz) {
wis <- array(data = 0, dim = c(N, M, length(probs)))
} else {
wis <- array(data = 0, dim = c((N * H), M, length(probs)))
}
}
# Compute the score (WIS)
if (horiz) {
for (n in 1:N) {
if (!quant) { # Missing implementation for more than one model
wis[n, ] <- apply(X = values[[n]], MARGIN = 1, FUN = compute_wis, probs = probs, y = y[n], average = (!quant))
} else {
if (M == 1) {
wis[n, , ] <- compute_wis(probs = probs, quant = values[[n]], y = y[n], average = (!quant))
} else {
wis[n, , ] <- apply(X = values[[n]], MARGIN = 1, FUN = compute_wis, probs = probs, y = y[n], average = (!quant)) |> t()
}
}
}
} else {
horizon <- as.numeric(names(y))
count <- 1
for (n in 1:N) {
for (h in 1:H) {
wis[count, , ] <- apply(X = values[[as.character(horizon[h])]][[n]], MARGIN = 1, FUN = compute_wis, probs = probs, y = y[[as.character(horizon[h])]][n], average = (!quant)) |> t()
count <- count + 1
}
}
}
##################################################
# Optimization routine
if (sum(wis, na.rm = TRUE) == 0) {
theta <- 0
} else {
if (!quant) {
# To be implemented
stop("To be implemented.")
} else {
theta <- rep(x = 0, times = length(probs))
phi <- rep(x = 0, times = length(probs))
for (q in 1:length(probs)) {
tmp_wis <- wis[, , q]
if (is.null(dim(tmp_wis))) {
tmp_wis <- t(as.matrix(tmp_wis))
}
est_pars <- grid_optim(probs = probs, values = values, y = y, q = q, quant = quant, M = M, wis = tmp_wis, by = by, theta_lim = c(lower, upper), horiz = horiz, short_grid_search = short_grid_search)
if (M == 1) {
phi[q] <- est_pars[1]
} else {
theta[q] <- est_pars[1]
phi[q]   <- est_pars[2]
}
}
}
}
##################################################
# Compute the new weights and nowcasts
if (!quant) {
w <- par_weights(theta = theta, wis = apply(X = wis, MARGIN = 2, FUN = mean))
result <- list(nowcast = w %*% current, weights = w, theta = theta)
} else {
w <- matrix(data = 0, nrow = length(probs), ncol = M)
if (horiz) {
nowcast <- rep(x = 0, times = length(probs))
} else {
nowcast <- matrix(data = 0, nrow = H, ncol = length(probs))
rownames(nowcast) <- horizon
}
tmp_wis_list <- list()
for (q in 1:length(probs)) {
tmp_wis <- wis[, , q]
if (is.null(dim(tmp_wis))) {
tmp_wis <- t(as.matrix(tmp_wis))
}
tmp_wis_list[[q]] <- apply(X = tmp_wis, MARGIN = 2, FUN = mean)
if (M == 1) {
w[q, ] <- phi[q]
} else {
w[q, ] <- par_weights_scale(theta = theta[q], phi = phi[q], wis = apply(X = tmp_wis, MARGIN = 2, FUN = mean))
}
if (horiz) {
if (M == 1) {
nowcast[q] <- w[q, ] %*% current[  q]
} else {
nowcast[q] <- w[q, ] %*% current[, q]
}
} else {
for (h in 1:H) {
nowcast[as.character(horizon[h]), q] <- w[q, ] %*% current[[as.character(horizon[h])]][[1]][, q]
}
}
}
if (TRUE) { # `name_values`
if (is.matrix(w)) { rownames(w) <- probs; colnames(w) <- ens_models }
if (is.vector(nowcast)) { names(nowcast) <- probs }
if (is.vector(theta)) { names(theta) <- probs }
}
result <- list(nowcast = nowcast, weights = w, theta = theta, phi = phi) # wis = tmp_wis_list)
}
result
}
##################################################
##################################################
##################################################
grid_optim <- function (probs, values, y, q, quant, M, wis = NULL, by = 0.01, theta_lim = c(-10, 10), phi_lim = c(0.75, 1.25), horiz = TRUE, short_grid_search = TRUE, ...) {
if (M == 1) {
wis <- t(wis)
pts <- seq(phi_lim[1], phi_lim[2], by = by)
rsp <- foreach(i = 1:length(pts)) %dopar% { cost_function(pars = pts[i], probs = probs, values = values, y = y, wis = wis, q = q, quant = quant, horiz = horiz) }
pts <- cbind(pts, unlist(rsp))
colnames(pts) <- c("phi", "cost")
pos <- which.min(pts[, 2])
result <- pts[pos, ]
} else {
theta <- seq(theta_lim[1], theta_lim[2], length.out = ((4 * 1 / by) + 1)) # length.out = ((2 * 1 / by) + 1)
phi <- seq(phi_lim[1], phi_lim[2], by = by)
pts <- expand.grid(theta, phi)
##################################################
if (short_grid_search) {
phi_1 <- which(phi == 1)
count  <- 1
before <- FALSE
after  <- FALSE
for (i in 1:((length(phi) - 1) / 2)) {
if (count == 1) {
# phi = 1
tmp_pts_1 <- pts[pts[, 2] == phi[phi_1], ]
tmp_rsp_1 <- foreach(i = 1:nrow(tmp_pts_1)) %dopar% { cost_function(pars = unlist(c(tmp_pts_1[i, ])), probs = probs, values = values, y = y, wis = wis, q = q, quant = quant, horiz = horiz) }
tmp_min_1 <- min(unlist(tmp_rsp_1))
tmp_par_1 <- c(unlist(c(tmp_pts_1[which.min(unlist(tmp_rsp_1)), 1:2])), tmp_min_1)
names(tmp_par_1) <- c("theta", "phi", "cost")
# before phi = 1
tmp_pts_b <- pts[pts[, 2] == phi[phi_1 - i], ]
tmp_rsp_b <- foreach(i = 1:nrow(tmp_pts_b)) %dopar% { cost_function(pars = unlist(c(tmp_pts_b[i, ])), probs = probs, values = values, y = y, wis = wis, q = q, quant = quant, horiz = horiz) }
tmp_min_b <- min(unlist(tmp_rsp_b))
tmp_par_b <- c(unlist(c(tmp_pts_b[which.min(unlist(tmp_rsp_b)), 1:2])), tmp_min_b)
names(tmp_par_b) <- c("theta", "phi", "cost")
# after  phi = 1
tmp_pts_a <- pts[pts[, 2] == phi[phi_1 + i], ]
tmp_rsp_a <- foreach(i = 1:nrow(tmp_pts_a)) %dopar% { cost_function(pars = unlist(c(tmp_pts_a[i, ])), probs = probs, values = values, y = y, wis = wis, q = q, quant = quant, horiz = horiz) }
tmp_min_a <- min(unlist(tmp_rsp_a))
tmp_par_a <- c(unlist(c(tmp_pts_a[which.min(unlist(tmp_rsp_a)), 1:2])), tmp_min_a)
names(tmp_par_a) <- c("theta", "phi", "cost")
if (tmp_min_1 <= min(tmp_min_b, tmp_min_a)) { before <- FALSE; after <- FALSE; tmp_par <- tmp_par_1
} else if (tmp_min_b <= min(tmp_min_1, tmp_min_a)) { before <- TRUE;  after <- FALSE; tmp_par <- tmp_par_b
} else if (tmp_min_a <= min(tmp_min_1, tmp_min_b)) { before <- FALSE; after <- TRUE;  tmp_par <- tmp_par_a } else { stop("Error 'min'") }
} else if ((before == TRUE ) & (after == FALSE)) {
tmp_pts_b <- pts[pts[, 2] == phi[phi_1 - i], ]
tmp_rsp_b <- foreach(i = 1:nrow(tmp_pts_b)) %dopar% { cost_function(pars = unlist(c(tmp_pts_b[i, ])), probs = probs, values = values, y = y, wis = wis, q = q, quant = quant, horiz = horiz) }
tmp_min_b <- min(unlist(tmp_rsp_b))
tmp_par_b <- c(unlist(c(tmp_pts_b[which.min(unlist(tmp_rsp_b)), 1:2])), tmp_min_b)
names(tmp_par_b) <- c("theta", "phi", "cost")
if (tmp_min_b < tmp_par[3]) {
tmp_par <- tmp_par_b
before  <- TRUE
after   <- FALSE
} else {
before  <- FALSE
after   <- FALSE
}
} else if ((before == FALSE) & (after == TRUE )) {
tmp_pts_a <- pts[pts[, 2] == phi[phi_1 + i], ]
tmp_rsp_a <- foreach(i = 1:nrow(tmp_pts_a)) %dopar% { cost_function(pars = unlist(c(tmp_pts_a[i, ])), probs = probs, values = values, y = y, wis = wis, q = q, quant = quant, horiz = horiz) }
tmp_min_a <- min(unlist(tmp_rsp_a))
tmp_par_a <- c(unlist(c(tmp_pts_a[which.min(unlist(tmp_rsp_a)), 1:2])), tmp_min_a)
names(tmp_par_a) <- c("theta", "phi", "cost")
if (tmp_min_a < tmp_par[3]) {
tmp_par <- tmp_par_a
before  <- FALSE
after   <- TRUE
} else {
before  <- FALSE
after   <- FALSE
}
} else if ((before == FALSE) & (after == FALSE)) {
# DO NOTHING
} else { stop("Error") }
count <- count + 1
}
result <- tmp_par
} else {
rsp <- foreach(i = 1:nrow(pts)) %dopar% { cost_function(pars = unlist(c(pts[i, ])), probs = probs, values = values, y = y, wis = wis, q = q, quant = quant, horiz = horiz) }
pts <- cbind(pts, unlist(rsp))
colnames(pts) <- c("theta", "phi", "cost")
pos <- which.min(pts$cost)
result <- unlist(c(pts[pos, 1:3]))
}
}
result
}
##################################################
##################################################
##################################################
cost_function <- function (pars, probs, values, y, wis, q = 1, quant = FALSE, horiz = TRUE, ...) {
if (length(pars) == 1) { # If just one model (post-processing)
phi <- pars
N <- length(values)
ens_wis <- rep(0, N)
w <- phi
for (n in 1:length(ens_wis)) {
ens_wis[n] <- compute_wis(probs = probs, quant = w %*% values[[n]], y = y[n], average = (!quant))[q]
}
} else {
theta <- pars[1]
phi   <- pars[2]
if (horiz) {
N <- length(values)
ens_wis <- rep(0, N)
} else {
H <- length(values)
N <- length(values[[1]])
ens_wis <- rep(0, (N * H))
}
w <- par_weights_scale(theta = theta, phi = phi, wis = apply(X = wis, MARGIN = 2, FUN = mean))
count_H <- 1
count_N <- 1
for (n in 1:length(ens_wis)) {
if (!quant) {
ens_wis[n] <- compute_wis(probs = probs, quant = w %*% values[[n]], y = y[n], average = (!quant))
} else {
if (horiz) {
ens_wis[n] <- compute_wis(probs = probs, quant = w %*% values[[n]], y = y[n], average = (!quant))[q]
} else {
ens_wis[n] <- compute_wis(probs = probs, quant = w %*% values[[count_H]][[count_N]], y = y[[count_H]][count_N], average = (!quant))[q]
}
}
count_N <- count_N + 1
if ((n %% N) == 0) {
count_H <- count_H + 1
count_N <- 1
}
}
}
mean(ens_wis, na.rm = TRUE)
}
##################################################
##################################################
##################################################
par_weights <- function (theta, wis, std_wis = TRUE, ...) {
wis <- mpfr(wis, 512)
if (std_wis) { wis <- wis / sum(wis) }
result <- as.numeric((exp(- theta * wis)) / (sum(exp(- theta * wis))))
result
}
par_weights_scale <- function (theta, phi, wis, std_wis = TRUE, ...) {
wis <- mpfr(wis, 512)
if (std_wis) { wis <- wis / sum(wis) }
result <- as.numeric(phi * (exp(- theta * wis)) / (sum(exp(- theta * wis))))
result
}
##################################################
##################################################
##################################################
for (k in 1:length(days)) {
dt <- days[k]
ensemble[[as.character(dt)]] <- list()
print(paste(dt, " (", sprintf("%03d", count), "/", sprintf("%03d", length(days)), ")", sep = ""))
b <- txtProgressBar(min = 1, max = length(horizon), initial = 1)
for (i in 1:length(horizon)) {
h <- horizon[i]
current_ens <- current[[as.character(dt)]][[as.character(h)]][[1]]
values_ens  <- values[[as.character(dt)]][[as.character(h)]]
# Analyze `NaN` values
# TBD
if (ens_method == "wis") {
tmp_result <- compute_ensemble(ens_method = ens_method, current = current_ens, weights = weights[[as.character(h)]], k = k)
} else if (ens_method == "pinball") {
tmp_result <- compute_ensemble(ens_method = ens_method,
y = y[[as.character(dt)]][[as.character(h)]],
y_current = y_current[[as.character(dt)]][[as.character(h)]],
values = values_ens,
current = current_ens,
ens_models = ens_models,
lower = -10,
upper = 10,
quant = quant,
horiz = horiz,
probs = probs,
short_grid_search = TRUE,
by = 0.01)
} else {
stop("Choose a valid ensemble method.")
}
ensemble[[as.character(dt)]][[as.character(h)]] <- tmp_result
# Input the new data to the `new_data` tibble
new_data <- input_new_data(new_data = new_data, ensemble = ensemble, ens_method = ens_method, h = h, state = state, age = age, day = dt, probs = probs)
setTxtProgressBar(b, i)
}
close(b)
count <- count + 1
}
new_data
