{
    "type": [
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        2,
        2,
        2,
        2
    ],
    "data": [
        "    }",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  weights",
        "+ ",
        "}",
        "> ",
        "",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "",
        "> ",
        "compute_wis_horizon_training <- function (wis_avg, models, quant = TRUE, probs = c(0.025, 0.100, 0.250, 0.500, 0.750, 0.900, 0.975), ...) {",
        "+ ",
        "  ",
        "+ ",
        "  horizon <- as.numeric(names(wis_avg))",
        "+ ",
        "  ",
        "+ ",
        "  if (!quant) {",
        "+ ",
        "    df_wis_horizon <- data.frame(model = rep(models, length(horizon)), horizon = rep(horizon, each = length(models)), wis = 0)  ",
        "+ ",
        "  } else {",
        "+ ",
        "    df_wis_horizon <- data.frame(model = rep(models, (length(horizon) * length(probs))), horizon = rep(rep(horizon, each = length(models)), length(probs)), probs = rep(probs, each = (length(models) * length(horizon))), wis = 0)  ",
        "+ ",
        "    df_wis_horizon$probs <- factor(x = df_wis_horizon$probs, levels = probs) ",
        "+ ",
        "  }",
        "+ ",
        "  df_wis_horizon$model <- factor(x = df_wis_horizon$model, levels = models) ",
        "+ ",
        "  ",
        "+ ",
        "  for (h in horizon) {",
        "+ ",
        "    df_wis_horizon[df_wis_horizon$horizon == h, \"wis\"] <- c(wis_avg[[as.character(h)]])",
        "+ ",
        "  } ",
        "+ ",
        "  ",
        "+ ",
        "  df_wis_horizon",
        "+ ",
        "}",
        "> ",
        "",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "",
        "> ",
        "create_new_tibble <- function (...) {",
        "+ ",
        "  as_tibble(data.frame(location         = character(), ",
        "+ ",
        "                       age_group        = character(), ",
        "+ ",
        "                       forecast_date    = as.Date(character()), ",
        "+ ",
        "                       target_end_date  = as.Date(character()), ",
        "+ ",
        "                       target           = character(), ",
        "+ ",
        "                       type             = character(), ",
        "+ ",
        "                       quantile         = double(), ",
        "+ ",
        "                       value            = double(), ",
        "+ ",
        "                       pathogen         = character(), ",
        "+ ",
        "                       model            = character(), ",
        "+ ",
        "                       retrospective    = logical(), ",
        "+ ",
        "                       stringsAsFactors = FALSE))",
        "+ ",
        "}",
        "> ",
        "",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "",
        "> ",
        "compute_ensemble <- function (ens_method, y, y_current, values, current, ens_models = NULL, weights = NULL, k = NULL, lower = -10, upper = 10, quant = TRUE, horiz = TRUE, probs = c(0.025, 0.100, 0.250, 0.500, 0.750, 0.900, 0.975), short_grid_search = TRUE, by = 0.01, ...) {",
        "+ ",
        "  m <- ens_method[1]",
        "+ ",
        "  ",
        "+ ",
        "  if (m == \"wis\") {",
        "+ ",
        "    res <- ensemble_wis(current = current, weights = weights, k = k)",
        "+ ",
        "  } else if (m == \"pinball\") {",
        "+ ",
        "    if (!horiz) { current <- list(current) } ",
        "+ ",
        "    res <- ensemble_pinball(y = y, y_current = y_currnt, values = values, current = current, ens_models = ens_models, lower = lower, upper = upper, quant = quant, horiz = horiz, probs = probs, short_grid_search = short_grid_search, by = by)",
        "+ ",
        "  } else {",
        "+ ",
        "    stop(\"Choose a valid ensemble method.\")",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  res",
        "+ ",
        "}",
        "> ",
        "",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "",
        "> ",
        "ensemble_wis <- function (current, weights, k = NULL, ...) {",
        "+ ",
        "  ",
        "+ ",
        "  if (length(dim(weights)) == 3) { # Weights depend on the quantiles",
        "+ ",
        "    res <- rep(0, length(probs))",
        "+ ",
        "    for (q in 1:length(probs)) {",
        "+ ",
        "      res[q] <- weights[k, , q] %*% current[, q]",
        "+ ",
        "    }",
        "+ ",
        "    weights <- weights[k, , ]",
        "+ ",
        "  } else { # Weights do not depend on the quantiles",
        "+ ",
        "    if (is.null(nrow(weights))) {",
        "+ ",
        "      res <- weights %*% current",
        "+ ",
        "    } else {",
        "+ ",
        "      res <- rep(0, length(probs))",
        "+ ",
        "      for (q in 1:length(probs)) {",
        "+ ",
        "        res[q] <- weights[, q] %*% current[, q]",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        " ",
        "+ ",
        "  list(nowcast = res, weights = weights)",
        "+ ",
        "}",
        "> ",
        "",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "",
        "> ",
        "input_new_data <- function (new_data, ensemble, ens_method, h, state, age, day, probs = c(0.025, 0.100, 0.250, 0.500, 0.750, 0.900, 0.975), ..) {",
        "+ ",
        "  ",
        "+ ",
        "  name_method <- ifelse(ens_method == \"wis\", \"DISW\", \"ISW\")",
        "+ ",
        "  ",
        "+ ",
        "  for (q in 1:length(probs)) {",
        "+ ",
        "    value <- ensemble[[as.character(dt)]][[as.character(h)]]$nowcast",
        "+ ",
        "    if (class(value)[1] == \"numeric\") {",
        "+ ",
        "      value <- value[q]",
        "+ ",
        "    } else  {",
        "+ ",
        "      value <- value[1, q]",
        "+ ",
        "    }",
        "+ ",
        "    new_data <- new_data |> add_row(location = state, age_group = age, forecast_date = dt, target_end_date = (dt + h), target = paste(h, \" day ahead inc hosp\", sep = \"\"), type = \"quantile\", quantile =  probs[q], value = value, pathogen = \"COVID-19\", model = name_method, retrospective = FALSE)",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  new_data",
        "+ ",
        "}",
        "> ",
        "",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "",
        "> ",
        "ensemble_pinball <- function (y, y_current, values, current, ens_models = NULL, lower = -10, upper = 10, quant = TRUE, horiz = TRUE, probs = c(0.025, 0.100, 0.250, 0.500, 0.750, 0.900, 0.975), short_grid_search = TRUE, by = 0.01, ...) {",
        "+ ",
        "  ",
        "+ ",
        "  if (!horiz & !quant) { stop(\"This combination of `quant` and `horiz` is not implemented.\") }",
        "+ ",
        "  ",
        "+ ",
        "  # H: number of horizons",
        "+ ",
        "  # N: number of day points",
        "+ ",
        "  # M: number of models",
        "+ ",
        "  ",
        "+ ",
        "  if (horiz) { # Weights depend on the horizons",
        "+ ",
        "    N <- length(values)",
        "+ ",
        "    M <- nrow(values[[1]])",
        "+ ",
        "    if (is.null(M)) {",
        "+ ",
        "      M <- 1",
        "+ ",
        "    }",
        "+ ",
        "  } else { # Weights do not depend on the horizons",
        "+ ",
        "    H <- length(values)",
        "+ ",
        "    N <- length(values[[1]])",
        "+ ",
        "    M <- nrow(values[[1]][[1]])",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  if (!quant) { # Weights do not depend on the quantiles",
        "+ ",
        "    wis <- matrix(data = 0, nrow = N, ncol = M)",
        "+ ",
        "  } else { # Weights depend on the quantiles",
        "+ ",
        "    if (horiz) {",
        "+ ",
        "      wis <- array(data = 0, dim = c(N, M, length(probs)))",
        "+ ",
        "    } else { ",
        "+ ",
        "      wis <- array(data = 0, dim = c((N * H), M, length(probs)))",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  # Compute the score (WIS)",
        "+ ",
        "  if (horiz) {",
        "+ ",
        "    for (n in 1:N) {",
        "+ ",
        "      if (!quant) { # Missing implementation for more than one model",
        "+ ",
        "        wis[n, ] <- apply(X = values[[n]], MARGIN = 1, FUN = compute_wis, probs = probs, y = y[n], average = (!quant))  ",
        "+ ",
        "      } else {",
        "+ ",
        "        if (M == 1) { ",
        "+ ",
        "          wis[n, , ] <- compute_wis(probs = probs, quant = values[[n]], y = y[n], average = (!quant))",
        "+ ",
        "        } else {",
        "+ ",
        "          wis[n, , ] <- apply(X = values[[n]], MARGIN = 1, FUN = compute_wis, probs = probs, y = y[n], average = (!quant)) |> t() ",
        "+ ",
        "        }",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "  } else { ",
        "+ ",
        "    horizon <- as.numeric(names(y))",
        "+ ",
        "    ",
        "+ ",
        "    count <- 1",
        "+ ",
        "    for (n in 1:N) {",
        "+ ",
        "      for (h in 1:H) {",
        "+ ",
        "        wis[count, , ] <- apply(X = values[[as.character(horizon[h])]][[n]], MARGIN = 1, FUN = compute_wis, probs = probs, y = y[[as.character(horizon[h])]][n], average = (!quant)) |> t()",
        "+ ",
        "        count <- count + 1",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  ##################################################",
        "+ ",
        "  ",
        "+ ",
        "  # Optimization routine",
        "+ ",
        "  if (sum(wis, na.rm = TRUE) == 0) {",
        "+ ",
        "    theta <- 0",
        "+ ",
        "  } else {",
        "+ ",
        "    if (!quant) {",
        "+ ",
        "      # To be implemented",
        "+ ",
        "      stop(\"To be implemented.\")",
        "+ ",
        "    } else {",
        "+ ",
        "",
        "+ ",
        "      theta <- rep(x = 0, times = length(probs))",
        "+ ",
        "      phi <- rep(x = 0, times = length(probs))",
        "+ ",
        "      ",
        "+ ",
        "      for (q in 1:length(probs)) {",
        "+ ",
        "        tmp_wis <- wis[, , q]",
        "+ ",
        "        if (is.null(dim(tmp_wis))) {",
        "+ ",
        "          tmp_wis <- t(as.matrix(tmp_wis)) ",
        "+ ",
        "        }",
        "+ ",
        "        est_pars <- grid_optim(probs = probs, values = values, y = y, q = q, quant = quant, M = M, wis = tmp_wis, by = by, theta_lim = c(lower, upper), horiz = horiz, short_grid_search = short_grid_search)",
        "+ ",
        "        if (M == 1) {",
        "+ ",
        "          phi[q] <- est_pars[1]",
        "+ ",
        "        } else {",
        "+ ",
        "          theta[q] <- est_pars[1]",
        "+ ",
        "          phi[q]   <- est_pars[2] ",
        "+ ",
        "        }",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  ##################################################",
        "+ ",
        "  ",
        "+ ",
        "  # Compute the new weights and nowcasts",
        "+ ",
        "  if (!quant) {",
        "+ ",
        "    w <- par_weights(theta = theta, wis = apply(X = wis, MARGIN = 2, FUN = mean))",
        "+ ",
        "    result <- list(nowcast = w %*% current, weights = w, theta = theta)",
        "+ ",
        "  } else {",
        "+ ",
        "    w <- matrix(data = 0, nrow = length(probs), ncol = M)",
        "+ ",
        "    if (horiz) {",
        "+ ",
        "      nowcast <- rep(x = 0, times = length(probs))",
        "+ ",
        "    } else {",
        "+ ",
        "      nowcast <- matrix(data = 0, nrow = H, ncol = length(probs))",
        "+ ",
        "      rownames(nowcast) <- horizon",
        "+ ",
        "    }",
        "+ ",
        "    tmp_wis_list <- list()",
        "+ ",
        "    for (q in 1:length(probs)) {",
        "+ ",
        "      tmp_wis <- wis[, , q]",
        "+ ",
        "      if (is.null(dim(tmp_wis))) {",
        "+ ",
        "        tmp_wis <- t(as.matrix(tmp_wis)) ",
        "+ ",
        "      }",
        "+ ",
        "      tmp_wis_list[[q]] <- apply(X = tmp_wis, MARGIN = 2, FUN = mean)",
        "+ ",
        "      if (M == 1) {",
        "+ ",
        "        w[q, ] <- phi[q]",
        "+ ",
        "      } else {",
        "+ ",
        "        w[q, ] <- par_weights_scale(theta = theta[q], phi = phi[q], wis = apply(X = tmp_wis, MARGIN = 2, FUN = mean))",
        "+ ",
        "      }",
        "+ ",
        "      if (horiz) {",
        "+ ",
        "        if (M == 1) {",
        "+ ",
        "          nowcast[q] <- w[q, ] %*% current[  q]",
        "+ ",
        "        } else {",
        "+ ",
        "          nowcast[q] <- w[q, ] %*% current[, q]",
        "+ ",
        "        }",
        "+ ",
        "      } else {",
        "+ ",
        "        for (h in 1:H) {",
        "+ ",
        "          nowcast[as.character(horizon[h]), q] <- w[q, ] %*% current[[as.character(horizon[h])]][[1]][, q]",
        "+ ",
        "        }",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "    ",
        "+ ",
        "    if (TRUE) { # `name_values`",
        "+ ",
        "      if (is.matrix(w)) { rownames(w) <- probs; colnames(w) <- ens_models }",
        "+ ",
        "      if (is.vector(nowcast)) { names(nowcast) <- probs }",
        "+ ",
        "      if (is.vector(theta)) { names(theta) <- probs }",
        "+ ",
        "    }",
        "+ ",
        "    ",
        "+ ",
        "    result <- list(nowcast = nowcast, weights = w, theta = theta, phi = phi) # wis = tmp_wis_list)",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  result",
        "+ ",
        "}",
        "> ",
        "",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "",
        "> ",
        "grid_optim <- function (probs, values, y, q, quant, M, wis = NULL, by = 0.01, theta_lim = c(-10, 10), phi_lim = c(0.75, 1.25), horiz = TRUE, short_grid_search = TRUE, ...) {",
        "+ ",
        "    ",
        "+ ",
        "    if (M == 1) { ",
        "+ ",
        "      ",
        "+ ",
        "      wis <- t(wis) ",
        "+ ",
        "      pts <- seq(phi_lim[1], phi_lim[2], by = by)",
        "+ ",
        "      rsp <- foreach(i = 1:length(pts)) %dopar% { cost_function(pars = pts[i], probs = probs, values = values, y = y, wis = wis, q = q, quant = quant, horiz = horiz) } ",
        "+ ",
        "      pts <- cbind(pts, unlist(rsp))",
        "+ ",
        "      colnames(pts) <- c(\"phi\", \"cost\")",
        "+ ",
        "      pos <- which.min(pts[, 2])",
        "+ ",
        "      result <- pts[pos, ]",
        "+ ",
        "      ",
        "+ ",
        "    } else {",
        "+ ",
        "      ",
        "+ ",
        "      theta <- seq(theta_lim[1], theta_lim[2], length.out = ((4 * 1 / by) + 1)) # length.out = ((2 * 1 / by) + 1)",
        "+ ",
        "      phi <- seq(phi_lim[1], phi_lim[2], by = by)",
        "+ ",
        "      ",
        "+ ",
        "      pts <- expand.grid(theta, phi)",
        "+ ",
        "      ",
        "+ ",
        "      ##################################################",
        "+ ",
        "      ",
        "+ ",
        "      if (short_grid_search) {",
        "+ ",
        "        phi_1 <- which(phi == 1)",
        "+ ",
        "        ",
        "+ ",
        "        count  <- 1",
        "+ ",
        "        before <- FALSE",
        "+ ",
        "        after  <- FALSE",
        "+ ",
        "        for (i in 1:((length(phi) - 1) / 2)) {",
        "+ ",
        "          ",
        "+ ",
        "          if (count == 1) {",
        "+ ",
        "            # phi = 1",
        "+ ",
        "            tmp_pts_1 <- pts[pts[, 2] == phi[phi_1], ]",
        "+ ",
        "            tmp_rsp_1 <- foreach(i = 1:nrow(tmp_pts_1)) %dopar% { cost_function(pars = unlist(c(tmp_pts_1[i, ])), probs = probs, values = values, y = y, wis = wis, q = q, quant = quant, horiz = horiz) }",
        "+ ",
        "            tmp_min_1 <- min(unlist(tmp_rsp_1))",
        "+ ",
        "            tmp_par_1 <- c(unlist(c(tmp_pts_1[which.min(unlist(tmp_rsp_1)), 1:2])), tmp_min_1)",
        "+ ",
        "            names(tmp_par_1) <- c(\"theta\", \"phi\", \"cost\")",
        "+ ",
        "            ",
        "+ ",
        "            # before phi = 1",
        "+ ",
        "            tmp_pts_b <- pts[pts[, 2] == phi[phi_1 - i], ]",
        "+ ",
        "            tmp_rsp_b <- foreach(i = 1:nrow(tmp_pts_b)) %dopar% { cost_function(pars = unlist(c(tmp_pts_b[i, ])), probs = probs, values = values, y = y, wis = wis, q = q, quant = quant, horiz = horiz) }",
        "+ ",
        "            tmp_min_b <- min(unlist(tmp_rsp_b))",
        "+ ",
        "            tmp_par_b <- c(unlist(c(tmp_pts_b[which.min(unlist(tmp_rsp_b)), 1:2])), tmp_min_b)",
        "+ ",
        "            names(tmp_par_b) <- c(\"theta\", \"phi\", \"cost\")",
        "+ ",
        "            ",
        "+ ",
        "            # after  phi = 1",
        "+ ",
        "            tmp_pts_a <- pts[pts[, 2] == phi[phi_1 + i], ]",
        "+ ",
        "            tmp_rsp_a <- foreach(i = 1:nrow(tmp_pts_a)) %dopar% { cost_function(pars = unlist(c(tmp_pts_a[i, ])), probs = probs, values = values, y = y, wis = wis, q = q, quant = quant, horiz = horiz) }",
        "+ ",
        "            tmp_min_a <- min(unlist(tmp_rsp_a))",
        "+ ",
        "            tmp_par_a <- c(unlist(c(tmp_pts_a[which.min(unlist(tmp_rsp_a)), 1:2])), tmp_min_a)",
        "+ ",
        "            names(tmp_par_a) <- c(\"theta\", \"phi\", \"cost\")",
        "+ ",
        "            ",
        "+ ",
        "            if (tmp_min_1 <= min(tmp_min_b, tmp_min_a)) { before <- FALSE; after <- FALSE; tmp_par <- tmp_par_1 ",
        "+ ",
        "            } else if (tmp_min_b <= min(tmp_min_1, tmp_min_a)) { before <- TRUE;  after <- FALSE; tmp_par <- tmp_par_b ",
        "+ ",
        "            } else if (tmp_min_a <= min(tmp_min_1, tmp_min_b)) { before <- FALSE; after <- TRUE;  tmp_par <- tmp_par_a } else { stop(\"Error 'min'\") }",
        "+ ",
        "            ",
        "+ ",
        "          } else if ((before == TRUE ) & (after == FALSE)) {",
        "+ ",
        "            ",
        "+ ",
        "            tmp_pts_b <- pts[pts[, 2] == phi[phi_1 - i], ]",
        "+ ",
        "            tmp_rsp_b <- foreach(i = 1:nrow(tmp_pts_b)) %dopar% { cost_function(pars = unlist(c(tmp_pts_b[i, ])), probs = probs, values = values, y = y, wis = wis, q = q, quant = quant, horiz = horiz) }",
        "+ ",
        "            tmp_min_b <- min(unlist(tmp_rsp_b))",
        "+ ",
        "            tmp_par_b <- c(unlist(c(tmp_pts_b[which.min(unlist(tmp_rsp_b)), 1:2])), tmp_min_b)",
        "+ ",
        "            names(tmp_par_b) <- c(\"theta\", \"phi\", \"cost\")",
        "+ ",
        "            ",
        "+ ",
        "            if (tmp_min_b < tmp_par[3]) {",
        "+ ",
        "              tmp_par <- tmp_par_b",
        "+ ",
        "              before  <- TRUE",
        "+ ",
        "              after   <- FALSE",
        "+ ",
        "            } else {",
        "+ ",
        "              before  <- FALSE",
        "+ ",
        "              after   <- FALSE",
        "+ ",
        "            }",
        "+ ",
        "            ",
        "+ ",
        "          } else if ((before == FALSE) & (after == TRUE )) {",
        "+ ",
        "            ",
        "+ ",
        "            tmp_pts_a <- pts[pts[, 2] == phi[phi_1 + i], ]",
        "+ ",
        "            tmp_rsp_a <- foreach(i = 1:nrow(tmp_pts_a)) %dopar% { cost_function(pars = unlist(c(tmp_pts_a[i, ])), probs = probs, values = values, y = y, wis = wis, q = q, quant = quant, horiz = horiz) }",
        "+ ",
        "            tmp_min_a <- min(unlist(tmp_rsp_a))",
        "+ ",
        "            tmp_par_a <- c(unlist(c(tmp_pts_a[which.min(unlist(tmp_rsp_a)), 1:2])), tmp_min_a)",
        "+ ",
        "            names(tmp_par_a) <- c(\"theta\", \"phi\", \"cost\")",
        "+ ",
        "            ",
        "+ ",
        "            if (tmp_min_a < tmp_par[3]) {",
        "+ ",
        "              tmp_par <- tmp_par_a",
        "+ ",
        "              before  <- FALSE",
        "+ ",
        "              after   <- TRUE",
        "+ ",
        "            } else {",
        "+ ",
        "              before  <- FALSE",
        "+ ",
        "              after   <- FALSE",
        "+ ",
        "            }",
        "+ ",
        "            ",
        "+ ",
        "          } else if ((before == FALSE) & (after == FALSE)) {",
        "+ ",
        "            # DO NOTHING",
        "+ ",
        "          } else { stop(\"Error\") }",
        "+ ",
        "          ",
        "+ ",
        "          count <- count + 1",
        "+ ",
        "        }",
        "+ ",
        "        ",
        "+ ",
        "        result <- tmp_par",
        "+ ",
        "      } else {",
        "+ ",
        "        ",
        "+ ",
        "        rsp <- foreach(i = 1:nrow(pts)) %dopar% { cost_function(pars = unlist(c(pts[i, ])), probs = probs, values = values, y = y, wis = wis, q = q, quant = quant, horiz = horiz) } ",
        "+ ",
        "        ",
        "+ ",
        "        pts <- cbind(pts, unlist(rsp))",
        "+ ",
        "        colnames(pts) <- c(\"theta\", \"phi\", \"cost\")",
        "+ ",
        "        pos <- which.min(pts$cost)",
        "+ ",
        "        ",
        "+ ",
        "        result <- unlist(c(pts[pos, 1:3]))",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "  ",
        "+ ",
        "  result",
        "+ ",
        "}",
        "> ",
        "",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "",
        "> ",
        "cost_function <- function (pars, probs, values, y, wis, q = 1, quant = FALSE, horiz = TRUE, ...) {",
        "+ ",
        "  ",
        "+ ",
        "  if (length(pars) == 1) { # If just one model (post-processing)",
        "+ ",
        "    ",
        "+ ",
        "    phi <- pars",
        "+ ",
        "    N <- length(values)",
        "+ ",
        "    ens_wis <- rep(0, N)",
        "+ ",
        "    w <- phi",
        "+ ",
        "    for (n in 1:length(ens_wis)) {",
        "+ ",
        "      ens_wis[n] <- compute_wis(probs = probs, quant = w %*% values[[n]], y = y[n], average = (!quant))[q]  ",
        "+ ",
        "    }",
        "+ ",
        "    ",
        "+ ",
        "  } else {",
        "+ ",
        "    theta <- pars[1]",
        "+ ",
        "    phi   <- pars[2]",
        "+ ",
        "    ",
        "+ ",
        "    if (horiz) {",
        "+ ",
        "      N <- length(values)",
        "+ ",
        "      ens_wis <- rep(0, N)",
        "+ ",
        "    } else { ",
        "+ ",
        "      H <- length(values)",
        "+ ",
        "      N <- length(values[[1]])",
        "+ ",
        "      ",
        "+ ",
        "      ens_wis <- rep(0, (N * H))",
        "+ ",
        "    }",
        "+ ",
        "    ",
        "+ ",
        "    w <- par_weights_scale(theta = theta, phi = phi, wis = apply(X = wis, MARGIN = 2, FUN = mean))",
        "+ ",
        "    ",
        "+ ",
        "    count_H <- 1",
        "+ ",
        "    count_N <- 1",
        "+ ",
        "    for (n in 1:length(ens_wis)) {",
        "+ ",
        "",
        "+ ",
        "      if (!quant) {",
        "+ ",
        "        ens_wis[n] <- compute_wis(probs = probs, quant = w %*% values[[n]], y = y[n], average = (!quant))  ",
        "+ ",
        "      } else {",
        "+ ",
        "        if (horiz) {",
        "+ ",
        "          ens_wis[n] <- compute_wis(probs = probs, quant = w %*% values[[n]], y = y[n], average = (!quant))[q]  ",
        "+ ",
        "        } else { ",
        "+ ",
        "          ens_wis[n] <- compute_wis(probs = probs, quant = w %*% values[[count_H]][[count_N]], y = y[[count_H]][count_N], average = (!quant))[q]  ",
        "+ ",
        "        }",
        "+ ",
        "      }",
        "+ ",
        "      ",
        "+ ",
        "      count_N <- count_N + 1",
        "+ ",
        "      if ((n %% N) == 0) {",
        "+ ",
        "        count_H <- count_H + 1  ",
        "+ ",
        "        count_N <- 1",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "    ",
        "+ ",
        "  }",
        "+ ",
        "  mean(ens_wis, na.rm = TRUE)",
        "+ ",
        "}",
        "> ",
        "",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "",
        "> ",
        "par_weights <- function (theta, wis, std_wis = TRUE, ...) {",
        "+ ",
        "  wis <- mpfr(wis, 512)",
        "+ ",
        "  if (std_wis) { wis <- wis / sum(wis) } ",
        "+ ",
        "  result <- as.numeric((exp(- theta * wis)) / (sum(exp(- theta * wis))))",
        "+ ",
        "  ",
        "+ ",
        "  result",
        "+ ",
        "}",
        "> ",
        "",
        "> ",
        "par_weights_scale <- function (theta, phi, wis, std_wis = TRUE, ...) {",
        "+ ",
        "  wis <- mpfr(wis, 512)",
        "+ ",
        "  if (std_wis) { wis <- wis / sum(wis) } ",
        "+ ",
        "  result <- as.numeric(phi * (exp(- theta * wis)) / (sum(exp(- theta * wis))))",
        "+ ",
        "  ",
        "+ ",
        "  result",
        "+ ",
        "}",
        "> ",
        "",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "##################################################",
        "> ",
        "for (k in 1:length(days)) { ",
        "+ ",
        "  dt <- days[k]",
        "+ ",
        "  ensemble[[as.character(dt)]] <- list()",
        "+ ",
        "  ",
        "+ ",
        "  print(paste(dt, \" (\", sprintf(\"%03d\", count), \"/\", sprintf(\"%03d\", length(days)), \")\", sep = \"\"))",
        "+ ",
        "  b <- txtProgressBar(min = 1, max = length(horizon), initial = 1) ",
        "+ ",
        "  ",
        "+ ",
        "  for (i in 1:length(horizon)) {",
        "+ ",
        "    h <- horizon[i]",
        "+ ",
        "    ",
        "+ ",
        "    current_ens <- current[[as.character(dt)]][[as.character(h)]][[1]]",
        "+ ",
        "    values_ens  <- values[[as.character(dt)]][[as.character(h)]]",
        "+ ",
        "    ",
        "+ ",
        "    # Analyze `NaN` values",
        "+ ",
        "    # TBD",
        "+ ",
        "    ",
        "+ ",
        "    if (ens_method == \"wis\") {",
        "+ ",
        "      tmp_result <- compute_ensemble(ens_method = ens_method, current = current_ens, weights = weights[[as.character(h)]], k = k)",
        "+ ",
        "    } else if (ens_method == \"pinball\") {",
        "+ ",
        "      tmp_result <- compute_ensemble(ens_method = ens_method,",
        "+ ",
        "                                    y = y[[as.character(dt)]][[as.character(h)]],",
        "+ ",
        "                                    y_current = y_current[[as.character(dt)]][[as.character(h)]],",
        "+ ",
        "                                    values = values_ens,",
        "+ ",
        "                                    current = current_ens,",
        "+ ",
        "                                    ens_models = ens_models,",
        "+ ",
        "                                    lower = -10,",
        "+ ",
        "                                    upper = 10, ",
        "+ ",
        "                                    quant = quant,",
        "+ ",
        "                                    horiz = horiz,",
        "+ ",
        "                                    probs = probs,",
        "+ ",
        "                                    short_grid_search = TRUE,",
        "+ ",
        "                                    by = 0.01)",
        "+ ",
        "    } else {",
        "+ ",
        "      stop(\"Choose a valid ensemble method.\")",
        "+ ",
        "    }",
        "+ ",
        "    ",
        "+ ",
        "    ensemble[[as.character(dt)]][[as.character(h)]] <- tmp_result",
        "+ ",
        "    ",
        "+ ",
        "    # Input the new data to the `new_data` tibble",
        "+ ",
        "    new_data <- input_new_data(new_data = new_data, ensemble = ensemble, ens_method = ens_method, h = h, state = state, age = age, day = dt, probs = probs)",
        "+ ",
        "  ",
        "+ ",
        "    setTxtProgressBar(b, i)",
        "+ ",
        "  }",
        "+ ",
        "  close(b)",
        "+ ",
        "  ",
        "+ ",
        "  count <- count + 1",
        "+ ",
        "}",
        "[1] \"2022-01-09 (001/111)\"\n=================================================================================================================\n[1] \"2022-01-10 (002/111)\"\n",
        "> ",
        "new_data",
        "\u001B[38;5;246m# A tibble: 210 × 11\u001B[39m\n   location age_group forecast_date target_end_date target      type  quantile value pathogen model retrospective\n   \u001B[3m\u001B[38;5;246m<chr>\u001B[39m\u001B[23m    \u001B[3m\u001B[38;5;246m<chr>\u001B[39m\u001B[23m     \u001B[3m\u001B[38;5;246m<date>\u001B[39m\u001B[23m        \u001B[3m\u001B[38;5;246m<date>\u001B[39m\u001B[23m          \u001B[3m\u001B[38;5;246m<chr>\u001B[39m\u001B[23m       \u001B[3m\u001B[38;5;246m<chr>\u001B[39m\u001B[23m    \u001B[3m\u001B[38;5;246m<dbl>\u001B[39m\u001B[23m \u001B[3m\u001B[38;5;246m<dbl>\u001B[39m\u001B[23m \u001B[3m\u001B[38;5;246m<chr>\u001B[39m\u001B[23m    \u001B[3m\u001B[38;5;246m<chr>\u001B[39m\u001B[23m \u001B[3m\u001B[38;5;246m<lgl>\u001B[39m\u001B[23m        \n",
        "\u001B[38;5;250m 1\u001B[39m DE       00+       2022-01-09    2021-12-12      -28 day ah… quan…    0.025 \u001B[4m9\u001B[24m605. COVID-19 ISW   FALSE        \n\u001B[38;5;250m 2\u001B[39m DE       00+       2022-01-09    2021-12-12      -28 day ah… quan…    0.1   \u001B[4m9\u001B[24m624. COVID-19 ISW   FALSE        \n\u001B[38;5;250m 3\u001B[39m DE       00+       2022-01-09    2021-12-12      -28 day ah… quan…    0.25  \u001B[4m9\u001B[24m634. COVID-19 ISW   FALSE        \n\u001B[38;5;250m 4\u001B[39m DE       00+       2022-01-09    2021-12-12      -28 day ah… quan…    0.5   \u001B[4m9\u001B[24m642. COVID-19 ISW   FALSE        \n",
        "\u001B[38;5;250m 5\u001B[39m DE       00+       2022-01-09    2021-12-12      -28 day ah… quan…    0.75  \u001B[4m9\u001B[24m693. COVID-19 ISW   FALSE        \n\u001B[38;5;250m 6\u001B[39m DE       00+       2022-01-09    2021-12-12      -28 day ah… quan…    0.9   \u001B[4m9\u001B[24m720. COVID-19 ISW   FALSE        \n\u001B[38;5;250m 7\u001B[39m DE       00+       2022-01-09    2021-12-12      -28 day ah… quan…    0.975 \u001B[4m9\u001B[24m679. COVID-19 ISW   FALSE        \n\u001B[38;5;250m 8\u001B[39m DE       00+       2022-01-09    2021-12-13      -27 day ah… quan…    0.025 \u001B[4m9\u001B[24m377. COVID-19 ISW   FALSE        \n",
        "\u001B[38;5;250m 9\u001B[39m DE       00+       2022-01-09    2021-12-13      -27 day ah… quan…    0.1   \u001B[4m9\u001B[24m395. COVID-19 ISW   FALSE        \n\u001B[38;5;250m10\u001B[39m DE       00+       2022-01-09    2021-12-13      -27 day ah… quan…    0.25  \u001B[4m9\u001B[24m408. COVID-19 ISW   FALSE        \n\u001B[38;5;246m# ℹ 200 more rows\u001B[39m\n\u001B[38;5;246m# ℹ Use `print(n = ...)` to see more rows\u001B[39m\n\nRestarting R session...\n\n"
    ]
}