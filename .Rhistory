Ap <- inla.spde.make.A(mesh = mesh, loc = coop)
dim(Ap)
coop
df_model
# stack for estimation stk.e
stk.e <- inla.stack(
tag = "est",
data = list(y = df_model$y, numtrials = df_model$n_obs),
# A = list(1, A),
A = A,
effects = list(data.frame(b0 = 1), s = indexs)
)
A
list(1, A)
list(1, A) == A
list(1, A) %>% c()
list(1, A)[[2]]
list(1, A)[[2]] %>% c()
list(1, A)[[2]][[1]] %>% c()
list(1, A)[[2]][[1]]
# stack for estimation stk.e
stk.e <- inla.stack(
tag = "est",
data = list(y = df_model$y, numtrials = df_model$n_obs),
# A = list(1, A),
A = A,
effects = list(data.frame(b0 = 1), s = indexs)
)
# stack for estimation stk.e
stk.e <- inla.stack(
tag = "est",
data = list(y = df_model$y),
A = list(1, A),
effects = list(data.frame(b0 = 1), s = indexs)
)
# stack for prediction stk.p
stk.p <- inla.stack(
tag = "pred",
data = list(y = NA),
A = list(1, Ap),
effects = list(data.frame(b0 = 1), s = indexs)
)
# stack for estimation stk.e
stk.e <- inla.stack(
tag = "est",
data = list(y = df_model$y),
A = list(1, A),
effects = list(data.frame(b0 = 1), s = indexs)
)
# stack for estimation stk.e
stk.e <- inla.stack(
tag = "est",
data = list(y = df_model$y),
A = list(1, A),
A = A,
effects = list(data.frame(b0 = 1), s = indexs)
)
# stack for estimation stk.e
stk.e <- inla.stack(
tag = "est",
data = list(y = df_model$y),
#A = list(1, A),
A = A,
effects = list(data.frame(b0 = 1), s = indexs)
)
# stack for estimation stk.e
stk.e <- inla.stack(
tag = "est",
data = list(y = df_model$y),
A = list(1, A),
#A = A,
effects = list(data.frame(b0 = 1), s = indexs)
)
nrow(A)
indexs
# stack for estimation stk.e
stk.e <- inla.stack(
tag = "est",
data = list(y = df_model$y),
A = list(1, A),
effects = list(data.frame(b0 = rep(1, nrow(coo))), s = indexs)
)
# stack for estimation stk.e
stk.e <- inla.stack(
tag = "est",
data = list(y = df_model$y),
A = list(1, A),
effects = list(data.frame(b0 = rep(1, nrow(coo))), s = indexs)
)
# stack for prediction stk.p
stk.p <- inla.stack(
tag = "pred",
data = list(y = NA, n_obs = NA),
A = list(1, Ap),
effects = list(data.frame(b0 = rep(1, nrow(coop))), s = indexs)
)
stk.full <- inla.stack(stk.e, stk.p)
formula <- y ~ b0 + f(s, model = spde)
inla.stack.data(stk.full)
# stack for estimation stk.e
stk.e <- inla.stack(
tag = "est",
data = list(y = df_model$y),
A = list(1, A),
effects = list(data.frame(b0 = rep(1, nrow(coo))), s = indexs)
)
# stack for prediction stk.p
stk.p <- inla.stack(
tag = "pred",
data = list(y = NA),
A = list(1, Ap),
effects = list(data.frame(b0 = rep(1, nrow(coop))), s = indexs)
)
stk.full <- inla.stack(stk.e, stk.p)
formula <- y ~ b0 + f(s, model = spde)
res <- inla(formula,
family = "binomial",
Ntrials = numtrials,
control.family = list(link = "logit"),
data = inla.stack.data(stk.full),
control.predictor = list(compute = TRUE, link = 1, A = inla.stack.A(stk.full)))
res <- inla(formula,
family = "binomial",
Ntrials = numtrials,
#control.family = list(link = "logit"),
data = inla.stack.data(stk.full),
control.predictor = list(compute = TRUE, link = 1, A = inla.stack.A(stk.full)))
df_model
# stack for estimation stk.e
stk.e <- inla.stack(
tag = "est",
data = list(y = df_model$y, numtrials = df_model$n_obs),
A = list(1, A),
effects = list(data.frame(b0 = rep(1, nrow(coo))), s = indexs)
)
# stack for prediction stk.p
stk.p <- inla.stack(
tag = "pred",
data = list(y = NA),
A = list(1, Ap),
effects = list(data.frame(b0 = rep(1, nrow(coop))), s = indexs)
)
stk.full <- inla.stack(stk.e, stk.p)
formula <- y ~ b0 + f(s, model = spde)
res <- inla(formula,
family = "binomial",
Ntrials = numtrials,
# control.family = list(link = "logit"),
data = inla.stack.data(stk.full),
control.predictor = list(compute = TRUE, link = 1, A = inla.stack.A(stk.full)))
idx <- inla.stack.index(stk.p, "pred")$data
idx
summary.fitted.values
res$summary.fitted.values
res$summary.fitted.values[idx, c("0.5quant")]
fitted_values <- res$summary.fitted.values[idx, c("0.5quant")]
fitted_values
fitted <- res$summary.fitted.values[idx, c("0.5quant")]
dim(fitted)
fitted
estimate
estimate
idx <- inla.stack.index(stk.p, "pred")$data
fitted <- res$summary.fitted.values[idx, c("0.5quant")]
plot (estimate, fitted_0.5quant, pch=16, col="red")
estimate
plot (estimate, fitted, pch = 16, col="red")
legend(0.01, 0.27, legend=c("INLA estimates, Besag"), col=c("red"), pch = c(16, 16), cex=0.8, title = "", text.font = 4, bg = "lightblue")
plot (estimate, fitted, pch = 16, col="red")
legend(0.01, 0.27, legend=c("INLA estimates, Besag"), col=c("red"), pch = c(16, 16), cex=0.8, title = "", text.font = 4, bg = "lightblue")
legend(0.01, 0.20, legend = c("INLA estimates, Besag"), col=c("red"), pch = c(16, 16), cex=0.8, title = "", text.font = 4, bg = "lightblue")
legend(0.01, 0.24, legend = c("INLA estimates, Besag"), col=c("red"), pch = c(16, 16), cex=0.8, title = "", text.font = 4, bg = "lightblue")
res <- inla(formula,
family = "binomial",
Ntrials = numtrials,
control.family = list(link = "logit"),
data = inla.stack.data(stk.full),
control.predictor = list(compute = TRUE, link = 1, A = inla.stack.A(stk.full)))
idx <- inla.stack.index(stk.p, "pred")$data
fitted <- res$summary.fitted.values[idx, c("0.5quant")]
plot (estimate, fitted, pch = 16, col="red")
legend(0.01, 0.24, legend = c("INLA estimates, Besag"), col=c("red"), pch = c(16, 16), cex=0.8, title = "", text.font = 4, bg = "lightblue", )
legend(0.01, 0.24, legend = c("INLA estimates, Besag"), col=c("red"), pch = c(16, 16), cex=0.8, title = "", text.font = 4, bg = "lightblue", asp = 1)
legend(0.01, 0.24, legend = c("INLA estimates, Besag"), col=c("red"), pch = c(16, 16), cex=0.8, title = "", text.font = 4, bg = "lightblue", asp = 1)
legend(0.01, 0.24, legend = c("INLA estimates, Besag"), col=c("red"), pch = c(16, 16), cex=0.8, title = "", text.font = 4, bg = "lightblue", asp = TRUE)
legend(0.01, 0.24, legend = c("INLA estimates, Besag"), col = c("red"), pch = c(16, 16), cex=0.8, title = "", text.font = 4, bg = "lightblue", asp = TRUE, xlim = c(0, 0.3), ylim = c(0, 0.3))
legend(0.01, 0.24, legend = c("INLA estimates, Besag"), col = c("red"), pch = c(16, 16), cex=0.8, title = "", text.font = 4, bg = "lightblue", xlim = c(0, 0.3), ylim = c(0, 0.3))
plot (estimate, fitted, pch = 16, col = "red", asp = 1)
plot (estimate, fitted, pch = 16, col = "red", xlim = c(0, 0.3), ylim = c(0, 0.3))
legend(0.01, 0.24, legend = c("INLA estimates, Besag"), col = c("red"), pch = c(16, 16), cex=0.8, title = "", text.font = 4, bg = "lightblue")
plot (estimate, fitted, pch = 16, col = "red", xlim = c(0, 0.3), ylim = c(0, 0.3), asp = 1)
plot (estimate, fitted, pch = 16, col = "red", xlim = c(0, 0.3), ylim = c(0, 0.3))
plot (estimate, fitted, pch = 16, col = "red", xlim = c(0, 0.3), ylim = c(0, 0.3), asp = 1)
plot (estimate, fitted, pch = 16, col = "red", asp = 1)
plot (estimate, fitted, pch = 16, col = "red", asp = 0)
plot (estimate, fitted, pch = 16, col = "red", asp = 1)
abline(a = 0, b = 1)
abline(a = 0, b = 1)
legend(0.01, 0.24, legend = c("INLA estimates, Besag"), col = c("red"), pch = c(16, 16), cex=0.8, title = "", text.font = 4, bg = "lightblue")
summary.fitted.values
coo
rnorm()
rnorm(1)
# Prediction points are the same as observation points
coop <- coo + rnorm(1, 0.5)
rnorm(1, 0.5)
rnorm(1, 0.1)
# Prediction points are the same as observation points
coop <- coo + 0.02
Ap <- inla.spde.make.A(mesh = mesh, loc = coop)
# Stack for estimation stk.e
stk.e <- inla.stack(
tag = "est",
data = list(y = df_model$y, numtrials = df_model$n_obs),
A = list(1, A),
effects = list(data.frame(b0 = rep(1, nrow(coo))), s = indexs)
)
# Stack for prediction stk.p
stk.p <- inla.stack(
tag = "pred",
data = list(y = NA),
A = list(1, Ap),
effects = list(data.frame(b0 = rep(1, nrow(coop))), s = indexs)
)
stk.full <- inla.stack(stk.e, stk.p)
coop
coop
# Prediction points are the same as observation points
coop <- coo + 0.02
Ap <- inla.spde.make.A(mesh = mesh, loc = coop)
# Stack for estimation stk.e
stk.e <- inla.stack(
tag = "est",
data = list(y = df_model$y, numtrials = df_model$n_obs),
A = list(1, A),
effects = list(data.frame(b0 = rep(1, nrow(coo))), s = indexs)
)
# Stack for estimation
stk.e <- inla.stack(
tag = "est",
data = list(y = df_model$y, numtrials = df_model$n_obs),
A = list(1, A),
effects = list(data.frame(b0 = rep(1, nrow(coo))), s = indexs)
)
# Stack for prediction
stk.p <- inla.stack(
tag = "pred",
data = list(y = NA),
A = list(1, Ap),
effects = list(data.frame(b0 = rep(1, nrow(coop))), s = indexs)
)
stk.full <- inla.stack(stk.e, stk.p)
# Prediction points are the same as observation points
coop <- rbind(coo + 0.02, coo - 0.02)
Ap <- inla.spde.make.A(mesh = mesh, loc = coop)
# Stack for estimation
stk.e <- inla.stack(
tag = "est",
data = list(y = df_model$y, numtrials = df_model$n_obs),
A = list(1, A),
effects = list(data.frame(b0 = rep(1, nrow(coo))), s = indexs)
)
# Stack for prediction
stk.p <- inla.stack(
tag = "pred",
data = list(y = NA),
A = list(1, Ap),
effects = list(data.frame(b0 = rep(1, nrow(coop))), s = indexs)
)
stk.full <- inla.stack(stk.e, stk.p)
formula <- y ~ b0 + f(s, model = spde)
res <- inla(formula,
family = "binomial",
Ntrials = numtrials,
control.family = list(link = "logit"),
data = inla.stack.data(stk.full),
control.predictor = list(compute = TRUE, link = 1, A = inla.stack.A(stk.full)))
res
res$summary.fitted.values
res$summary.fitted.values %>% tail()
coo <- cbind(x_coords, y_coords)
mesh <- inla.mesh.2d(loc = coo, max.edge = c(0.1, 5), cutoff = 0.01)
plot(mesh)
points(coo, col = "red")
spde <- inla.spde2.matern(mesh = mesh, alpha = 2, constr = TRUE)
indexs <- inla.spde.make.index("s", spde$n.spde)
A <- inla.spde.make.A(mesh = mesh, loc = coo)
# Prediction points are the same as observation points
coop <- coo
Ap <- inla.spde.make.A(mesh = mesh, loc = coop)
# Stack for estimation
stk.e <- inla.stack(
tag = "est",
data = list(y = df_model$y, numtrials = df_model$n_obs),
A = list(1, A),
effects = list(data.frame(b0 = rep(1, nrow(coo))), s = indexs)
)
# Stack for prediction
stk.p <- inla.stack(
tag = "pred",
data = list(y = NA),
A = list(1, Ap),
effects = list(data.frame(b0 = rep(1, nrow(coop))), s = indexs)
)
# Stack for prediction
stk.p <- inla.stack(
tag = "pred",
data = list(y = NA, numtrials = df_model$n_obs),
A = list(1, Ap),
effects = list(data.frame(b0 = rep(1, nrow(coop))), s = indexs)
)
stk.full <- inla.stack(stk.e, stk.p)
formula <- y ~ b0 + f(s, model = spde)
res <- inla(formula,
family = "binomial",
Ntrials = numtrials,
control.family = list(link = "logit"),
data = inla.stack.data(stk.full),
control.predictor = list(compute = TRUE, link = 1, A = inla.stack.A(stk.full)))
idx <- inla.stack.index(stk.p, "pred")$data
fitted <- res$summary.fitted.values[idx, c("0.5quant")]
plot(estimate, fitted, pch = 16, col = "red")
abline(a = 0, b = 1)
res
res$summary.fitted.values
fitted
res$summary.fitted.values
res$summary.fitted.values %>% tail()
126 - 64
A
coo <- cbind(x_coords, y_coords)
mesh <- inla.mesh.2d(loc = coo, max.edge = c(0.1, 5), cutoff = 0.01)
plot(mesh)
points(coo, col = "red")
spde <- inla.spde2.matern(mesh = mesh, alpha = 2, constr = TRUE)
indexs <- inla.spde.make.index("s", spde$n.spde)
A <- inla.spde.make.A(mesh = mesh, loc = coo)
# Prediction points are the same as observation points
coop <- coo
Ap <- inla.spde.make.A(mesh = mesh, loc = coop)
# Stack for estimation
stk.e <- inla.stack(
tag = "est",
data = list(y = df_model$y, numtrials = df_model$n_obs),
A = list(1, A),
effects = list(data.frame(b0 = rep(1, nrow(coo))), s = indexs)
)
# Stack for prediction
stk.p <- inla.stack(
tag = "pred",
data = list(y = NA),
A = list(1, Ap),
effects = list(data.frame(b0 = rep(1, nrow(coop))), s = indexs)
)
stk.full <- inla.stack(stk.e, stk.p)
formula <- y ~ b0 + f(s, model = spde)
res <- inla(formula,
family = "binomial",
Ntrials = numtrials,
control.family = list(link = "logit"),
data = inla.stack.data(stk.full),
control.predictor = list(compute = TRUE, link = 1, A = inla.stack.A(stk.full)))
idx <- inla.stack.index(stk.p, "pred")$data
fitted <- res$summary.fitted.values[idx, c("0.5quant")]
plot(estimate, fitted, pch = 16, col = "red")
abline(a = 0, b = 1)
legend(0.01, 0.24, legend = c("INLA estimates, Besag"), col = c("red"), pch = c(16, 16), cex = 0.8, title = "", text.font = 4, bg = "lightblue")
args <- commandArgs(trailingOnly = TRUE)
all_states <- as.logical(args[1])
source("header.R")
source("utils.R")
source("aux.R")
ens_method <- "pinball" # c("wis", "pinball")
skip_recent_days <- FALSE # c(TRUE, FALSE)
training_size <- 90
uncertain_size <- 40
exploratory_wis <- FALSE # Plotting score for all individual and naive ensemble models
ignore_naive_ensemble_data <- TRUE # Remove naive ensembles from the data objects, so the trained models do not take them as inputs
quant <- TRUE # Weights depend (or not) on the quantiles
horiz <- FALSE # Weights depend (or not) on the horizons # Only implemented for `TRUE` for stratified analysis
post_processing <- FALSE
post_select_mod <- "Epiforecasts"
state_idx <- 17 # c(1:16, 17)
age_idx <- 7 # c(1:6, 7)
method <- "Mean" # c("Mean", "Median", "all_quant")
cluster_size <- 4
data <- read_csv(file = "DATA/data.csv.gz")
truth_data <- read_csv(file = "DATA/truth_40d.csv.gz")
state <- unique(data$location)
state <- c(state, "DE")
state <- state[2:length(state)][state_idx]
age <- unique(data$age_group)
age <- c(age, "00+")
age <- age[2:length(age)][age_idx]
models <- c("Epiforecasts", "ILM", "KIT", "LMU", "RIVM", "RKI", "SU", "SZ")
colors <- c("#B30000", "#E69F00", "#56B4E9", "#F0E442", "#80471C", "#3C4AAD", "#CC79A7", "#000000")
if ((length(state) == 1) & (length(age) == 1)) {
if ((state == "DE") & (age == "00+")) {
idx_missing_model <- -(1:length(models))
} else if ((state == "DE") & (age != "00+")) {
idx_missing_model <- which(models == "RKI")
} else if ((state != "DE") & (age == "00+")) {
idx_missing_model <- which(models == "ILM")
} else { stop("This combination of `state` and `age` does not exist.") }
} else {
if (length(age) != 1) {
idx_missing_model <- which(models == "RKI")
} else if (length(state) != 1) {
idx_missing_model <- which(models == "ILM")
} else { stop("Error.") }
}
models <- models[-idx_missing_model]
colors <- colors[-idx_missing_model]
ens_models <- models
ens_colors <- colors
filtered_data <- filter_data(data = data, truth_data = truth_data, models = models, loc = state, age_gr = age, extra_delay = 7, truth_past = training_size)
data <- filtered_data$data
truth_data <- filtered_data$truth_data
r <- range(data$forecast_date)
horizon <- -28:0
probs <- c(0.025, 0.100, 0.250, 0.500, 0.750, 0.900, 0.975)
filter_data
data <- read_csv(file = "DATA/data.csv.gz")
data
data$model %>% unique()
KIT-frozen_baseline <- data %>% filter(model == "KIT-frozen_baseline")
data
KIT-frozen_baseline <- data %>% filter(model == "KIT-frozen_baseline")
KIT_frozen_baseline <- data %>% filter(model == "KIT-frozen_baseline")
data <- read_csv(file = "DATA/data.csv.gz")
truth_data <- read_csv(file = "DATA/truth_40d.csv.gz")
KIT_frozen_baseline <- data %>% filter(model == "KIT-frozen_baseline")
state <- unique(data$location)
state <- c(state, "DE")
state <- state[2:length(state)][state_idx]
age <- unique(data$age_group)
age <- c(age, "00+")
age <- age[2:length(age)][age_idx]
models <- c("Epiforecasts", "ILM", "KIT", "LMU", "RIVM", "RKI", "SU", "SZ")
colors <- c("#B30000", "#E69F00", "#56B4E9", "#F0E442", "#80471C", "#3C4AAD", "#CC79A7", "#000000")
models_orig <- models
colors_orig <- colors
filtered_data <- filter_data(data = data, truth_data = truth_data, models = models, loc = state, age_gr = age, extra_delay = 7, truth_past = training_size)
data <- filtered_data$data
truth_data <- filtered_data$truth_data
models <- c("Mean", "Median", "DISW (St.1.)", "DISW (St.2.)", "ISW (St.1.)", "ISW (St.2.)")
colors <- c("#009E73", "#60D1B3", "#9400D3", "#9370DB", "#C71585", "#FF1493")
naive_ensemble_file <- paste("DATA/UNTRAINED_ENSEMBLE/naive_ensemble_state_", state, "_age_", age, ".RDS", sep = "")
naive_ensemble <- readRDS(file = naive_ensemble_file)
data <- rbind(data, naive_ensemble)
source("header.R")
source("utils.R")
source("aux.R")
ens_method <- "pinball" # c("wis", "pinball")
skip_recent_days <- FALSE # c(TRUE, FALSE)
training_size <- 90
uncertain_size <- 40
exploratory_wis <- FALSE # Plotting score for all individual and naive ensemble models
ignore_naive_ensemble_data <- TRUE # Remove naive ensembles from the data objects, so the trained models do not take them as inputs
quant <- TRUE # Weights depend (or not) on the quantiles
horiz <- FALSE # Weights depend (or not) on the horizons # Only implemented for `TRUE` for stratified analysis
post_processing <- FALSE
post_select_mod <- "Epiforecasts"
state_idx <- 17 # c(1:16, 17)
age_idx <- 7 # c(1:6, 7)
method <- "Mean" # c("Mean", "Median", "all_quant")
cluster_size <- 4
data <- read_csv(file = "DATA/data.csv.gz")
truth_data <- read_csv(file = "DATA/truth_40d.csv.gz")
KIT_frozen_baseline <- data %>% filter(model == "KIT-frozen_baseline")
state <- unique(data$location)
state <- c(state, "DE")
state <- state[2:length(state)][state_idx]
age <- unique(data$age_group)
age <- c(age, "00+")
age <- age[2:length(age)][age_idx]
models <- c("Epiforecasts", "ILM", "KIT", "LMU", "RIVM", "RKI", "SU", "SZ")
colors <- c("#B30000", "#E69F00", "#56B4E9", "#F0E442", "#80471C", "#3C4AAD", "#CC79A7", "#000000")
if ((length(state) == 1) & (length(age) == 1)) {
if ((state == "DE") & (age == "00+")) {
idx_missing_model <- -(1:length(models))
} else if ((state == "DE") & (age != "00+")) {
idx_missing_model <- which(models == "RKI")
} else if ((state != "DE") & (age == "00+")) {
idx_missing_model <- which(models == "ILM")
} else { stop("This combination of `state` and `age` does not exist.") }
} else {
if (length(age) != 1) {
idx_missing_model <- which(models == "RKI")
} else if (length(state) != 1) {
idx_missing_model <- which(models == "ILM")
} else { stop("Error.") }
}
models <- models[-idx_missing_model]
colors <- colors[-idx_missing_model]
ens_models <- models
ens_colors <- colors
filtered_data <- filter_data(data = data, truth_data = truth_data, models = models, loc = state, age_gr = age, extra_delay = 7, truth_past = training_size)
data <- filtered_data$data
truth_data <- filtered_data$truth_data
r <- range(data$forecast_date)
horizon <- -28:0
probs <- c(0.025, 0.100, 0.250, 0.500, 0.750, 0.900, 0.975)
r
KIT_frozen_baseline <- KIT_frozen_baseline %>% filter(forecast_date >= r[1], forecast_date <= r[2])
KIT_frozen_baseline
data
data %>% filter(model == "Epiforecasts")
age
state
KIT_frozen_baseline <- KIT_frozen_baseline %>% filter(forecast_date >= r[1], forecast_date <= r[2], age_group == age, location == state)
KIT_frozen_baseline
